[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Álgebra Computacional com GAP",
    "section": "",
    "text": "1 MiniCursoGAP\nEste material foi preparado para o minicurso de Álgebra Computacional com GAP que foi realizado na XXVII Escola de Álgebra em São Paulo (2024). Durante as 5 sessões do minicurso, os participantes trabalham individualmente ou em pares em vários pequenos projetos com o objetivo de explorar as várias funcionalidades do sistema computacional GAP. Os projetos representem vários níveis de habilidade matemática e computacional.\n\nRodar o sistema, criar, salvar e carregar arquivos\nAritmética básica, variáveis, funções\nListas, matrizes, permutações\nO primeiro encontro com grupos\nA linguagem de programação\nOs números de Erdős-Woods\nA Conjetura de Collatz\nNúmeros perfeitos, abundantes, e sequências alíquotas\nCriptografia RSA\nComutadores de grupos\nGrupos livres, homomorfismos, Exploração do cubo mágico\nUma exploração dos centralizadores\nHomomorfismos, automorfismos, de grupos\nCarateres de um grupo e a ordem generalizada\nÁlgebras associativas\nUm problema de álgebra comutativa\nDependência algébrica de polinômios\nTeoria de grafos",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>MiniCursoGAP</span>"
    ]
  },
  {
    "objectID": "arith.html",
    "href": "arith.html",
    "title": "2  Aritmética básica",
    "section": "",
    "text": "2.1 Operações aritméticas",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Aritmética básica</span>"
    ]
  },
  {
    "objectID": "arith.html#sec-ops-arit",
    "href": "arith.html#sec-ops-arit",
    "title": "2  Aritmética básica",
    "section": "",
    "text": "As operações mais comuns em GAP são + (adição), - (subtração), * (multiplicação), / (divisão), mod, (resto) ^ (exponenciação). Experimente com os seguintes exemplos.\ngap&gt; 2+3;\n5\ngap&gt; 2/4;\n1/2\ngap&gt; (2+3)*(1/2);\n5/2\ngap&gt; 2^3*3;\n24\ngap&gt; 6 mod 4;\n2\ngap&gt; -6 mod 4;\n2\ngap&gt; 2^-2*3;\n3/4\ngap&gt; 2.0;\n2.\ngap&gt; 2.01+3.11;\n5.12\ngap&gt; 1/3;\n1/3\ngap&gt; 1.0/3;\n0.333333\nNote a diferença entre trabalhar com valores exatos (como por exemplo 1/3) e valores aproximados (por exemplo 1.0/3).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Aritmética básica</span>"
    ]
  },
  {
    "objectID": "arith.html#sec-bool",
    "href": "arith.html#sec-bool",
    "title": "2  Aritmética básica",
    "section": "2.2 Operações lógicas (booleanas)",
    "text": "2.2 Operações lógicas (booleanas)\n\nPara comparar se dois valores são iguais, usamos a operação = cujo valor é um valor lógico ou seja true ou false. As operações com valores lógicos são not, and e or que funcionam exatamente como os respetivos conetivos na lógica matemática.\ngap&gt; 2 + 3 = 5;\ntrue\ngap&gt; 2 + 3 = 5 or 2 + 3 = 6;\ntrue\ngap&gt; 2 + 3 = 5 and 2 + 3 = 6;\nfalse\ngap&gt; 2 + 3 = 5 and  not 2 + 3 = 6;\ntrue\nNote também que a operção “não igual” é escrita como &lt;&gt;. Por exemplo\ngap&gt; 2 &lt;&gt; 3;\ntrue\ngap&gt; 3 &lt;&gt; 3;\nfalse",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Aritmética básica</span>"
    ]
  },
  {
    "objectID": "arith.html#sec-vars",
    "href": "arith.html#sec-vars",
    "title": "2  Aritmética básica",
    "section": "2.3 Variáveis",
    "text": "2.3 Variáveis\n\nAs variáveis guardam valores que podem ser usados durante a computação. Uma variável é uma palavra de letras, números e alguns carateres especiais. Aqui é um exemplo simples.\ngap&gt; a := 2;\n2\ngap&gt; a3 := 3;\n3\ngap&gt; a_5 := 5;\n5\ngap&gt; a := 2; \n2\ngap&gt; b := 3;\n3\ngap&gt; a + b; a*b;\n5\n6\nVariávies podem conter valores mais complexos, como nos seguintes exemplos.\ngap&gt; s1 := \"Hello\";\n\"Hello\"\ngap&gt; s2 := \" World!\";\n\" World!\"\ngap&gt; Concatenation( s1, s2 );\n\"Hello World!\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Aritmética básica</span>"
    ]
  },
  {
    "objectID": "arith.html#sec-ff",
    "href": "arith.html#sec-ff",
    "title": "2  Aritmética básica",
    "section": "2.4 Corpos finitos",
    "text": "2.4 Corpos finitos\n\nQuando trabalhamos com estruturas algébricas, precisamos trabalhar com corpos além do corpo \\(\\mathbb Q\\). Aqui em baixo veremos alguns exemplos para aritmética com (corpos finitos)[https://docs.gap-system.org/doc/ref/chap59.html]. O corpo finito com \\(q\\) elementos pode ser construído com a função GF( q ).\ngap&gt; GF(3);\nGF(3)\ngap&gt; GF(5);\nGF(5)\ngap&gt; GF(27);\nGF(3^3)\nSabemos que o grupo multiplicativo de um corpo finito é cíclico. Isso quer dizer que para todo corpo finito \\(\\mathbb F\\), existe um elemento \\(z\\in \\mathbb F\\) tal que os elementos não nulos de \\(\\mathbb F\\) são as potências de \\(z\\); ou seja, \\[\n\\mathbb F=\\{0\\}\\cup \\{z^0,z^1,\\ldots,z^{q-2}\\}\n\\] onde \\(q=|\\mathbb F|\\). Este elemento chama-se elemento primitivo de \\(\\mathbb F\\). Para uma potência de primo q, função Z( q ) devolve um elemento primitivo explícito do corpo finito GF( q ) (Galois Field). Os elementos não nulos de GF( q ) são representados como potências de Z( q ). Considere os seguintes exemplos.\ngap&gt; F := GF(11);\nGF(11)\ngap&gt; e := One( F );\nZ(11)^0\ngap&gt; z := Zero( F );\n0*Z(11)\ngap&gt; p := PrimitiveElement( F );\nZ(11)\ngap&gt; e+p;\nZ(11)^8\ngap&gt; e+p^2;\nZ(11)^4\nQuando trabalhamos com o corpo \\(\\mathbb Z_p\\), é frequentamente necessário considerar elementos de \\(\\mathbb Z_p\\) como inteiros e vice versa. Nos seguintes exemplos, vamos ver como fazer isso em GAP.\ngap&gt; F := GF(11);\nGF(11)\ngap&gt; a := 2*One(F); \nZ(11)\ngap&gt; b := 2*Z(11)^0;\nZ(11)\ngap&gt; a = b;\ntrue\ngap&gt; a1 := IntFFE( a );\n2\ngap&gt; b1 := IntFFE( b );\n2\ngap&gt; a1 in F;\nfalse\ngap&gt; a1 in Integers;\ntrue\ngap&gt; a1 = b1;\ntrue",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Aritmética básica</span>"
    ]
  },
  {
    "objectID": "list_mat_perm.html",
    "href": "list_mat_perm.html",
    "title": "3  Listas, matrizes e permutações",
    "section": "",
    "text": "3.1 Listas",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Listas, matrizes e permutações</span>"
    ]
  },
  {
    "objectID": "list_mat_perm.html#sec-list",
    "href": "list_mat_perm.html#sec-list",
    "title": "3  Listas, matrizes e permutações",
    "section": "",
    "text": "Listas são importantes em GAP (manual). Listas contém uma sequência de objetos. Os objetos nas listas podem ser números, carateres, ou até objetos complexos, tais como grupos, subgrupos de um grupo, etc. Os seguintes exemplos mostram a criação de listas e as operações básicas com listas.\ngap&gt; L := [1..10]\n[ 1 .. 10 ]\ngap&gt; L1 := [1,3,5,7,9,10,8,6,4,2,0];\n[ 1, 3, 5, 7, 9, 10, 8, 6, 4, 2, 0 ]\ngap&gt; L2 := [\"a\",\"b\",\"c\",\"z\",\"x\",\"y\"];\n[ \"a\", \"b\", \"c\", \"z\", \"x\", \"y\" ]\nPara acessar os elementos de uma lista, usamos list[n] que devolve o \\(n\\)-ésimo elemento começando por list[1]. Para verificar se um objeto pertence ou não a uma lista, pode usar o operador in.\ngap&gt; L1[3];\n5\ngap&gt; 10 in L1;\ntrue\ngap&gt; 10 in L2;\nfalse\ngap&gt; \"a\" in L2;\ntrue\nA posição de um elemento em uma lista pode ser determinada usando a função Position.\ngap&gt; Position( L1, 10 );\n6\ngap&gt; Position( L1, -1 );\nfail\nFrequentamente, precisa-se criar novas listas usando listas. Por exemplo, frequentamente queremos criar a lista de elementos de uma outra lista que satisfazem uma certa propriedade. Esta tarefa pode ser resolvida usando a função Filtered( list, func ) em GAP onde list é uma lista e func é uma função (Seção 5.5). Nos seguintes exemplos veremos alguns usos simples desta construção.\ngap&gt; Filtered( L1, IsEvenInt );\n[ 10, 8, 6, 4, 2, 0 ]\ngap&gt; Filtered( L1, IsOddInt );\n[ 1, 3, 5, 7, 9 ]\ngap&gt; Filtered( L1, x -&gt; x mod 2 = 0 );\n[ 10, 8, 6, 4, 2, 0 ]\ngap&gt; Filtered( L1, x -&gt; x mod 2 = 1 );\n[ 1, 3, 5, 7, 9 ]\nNovas listas podem ser criadas também aplicando uma função nos elementos de uma outra lista. Por exemplo, criamos a lista dos quadrados dos primeiros 10 números naturais:\ngap&gt; List( [1..10], x-&gt;x^2 );\n[ 1, 4, 9, 16, 25, 36, 49, 64, 81, 100 ]\nGAP trabalha também com listas nas quais algumas entradas não estão definidas. Considere por exemplo as seguintes instruções.\ngap&gt; l := [1,2,,,12];\n[ 1, 2,,, 12 ]\ngap&gt; l[1];\n1\ngap&gt; l[2];\n2\ngap&gt; l[3];\nError, List Element: &lt;list&gt;[3] must have an assigned value\nnot in any function at *stdin*:166\ntype 'quit;' to quit to outer loop\nbrk&gt; quit;\ngap&gt; IsBound( l[3] );\nfalse\ngap&gt; IsBound( l[4] );\nfalse\ngap&gt; IsBound( l[5] );\ntrue\ngap&gt; l[5];\n12\ngap&gt; \ngap&gt; l[8] := 22;\n22\ngap&gt; l;\n[ 1, 2,,, 12,,, 22 ]\nNote que, ao acessar l[3], obtemos um erro, pois esta entrada não existe. Para evitar este erro, podemos verificar se existe ou não a entrada usando IsBound.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Listas, matrizes e permutações</span>"
    ]
  },
  {
    "objectID": "list_mat_perm.html#sec-matrix",
    "href": "list_mat_perm.html#sec-matrix",
    "title": "3  Listas, matrizes e permutações",
    "section": "3.2 Matrizes",
    "text": "3.2 Matrizes\n\nEm GAP uma matriz é lista de listas (que são as linhas da matriz) (manual). As entradas de matrizes são tipicamente números ou, mais geralmente, elementos de um anel ou corpo. As matrizes podem ser somadas e multiplicadas exatamente como números.\ngap&gt; m1 := [[1,2,0],[0,-2,3]];\n[ [ 1, 2, 0 ], [ 0, -2, 3 ] ]\ngap&gt; Display( m1 );\n[ [   1,   2,   0 ],\n  [   0,  -2,   3 ] ]\ngap&gt; m2 := [[1,-1],[0,3],[4,1/2]];\n[ [ 1, -1 ], [ 0, 3 ], [ 4, 1/2 ] ]\ngap&gt; Display( m2 );\n[ [    1,   -1 ],\n  [    0,    3 ],\n  [    4,  1/2 ] ]\ngap&gt; m1*m2;\n[ [ 1, 5 ], [ 12, -9/2 ] ]\ngap&gt; Display( last );\n[ [     1,     5 ],\n  [    12,  -9/2 ] ]\ngap&gt; m2*m1;\n[ [ 1, 4, -3 ], [ 0, -6, 9 ], [ 4, 7, 3/2 ] ]\ngap&gt; Display( last );\n[ [    1,    4,   -3 ],\n  [    0,   -6,    9 ],\n  [    4,    7,  3/2 ] ]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Listas, matrizes e permutações</span>"
    ]
  },
  {
    "objectID": "list_mat_perm.html#sec-permutation",
    "href": "list_mat_perm.html#sec-permutation",
    "title": "3  Listas, matrizes e permutações",
    "section": "3.3 Permutações",
    "text": "3.3 Permutações\n\nOutro objeto fundamento quando trabalhamos com grupos finitos é a permutação. Permutações em GAP podem ser definidas como produto de cíclos disjuntos mas também usando uma lista.\ngap&gt; p1 := (1,2,3)(4,5,6);\n(1,2,3)(4,5,6)\ngap&gt; p1^2;\n(1,3,2)(4,6,5)\ngap&gt; p2 := PermList( [1,5,4,3,2] );\n(2,5)(3,4)\ngap&gt; p1*p2;\n(1,5,6,3)(2,4)\ngap&gt; p2*p1;\n(1,2,6,4)(3,5)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Listas, matrizes e permutações</span>"
    ]
  },
  {
    "objectID": "estrut.html",
    "href": "estrut.html",
    "title": "4  O primeiro encontro com grupos",
    "section": "",
    "text": "4.1 Grupos disponíveis na biblioteca",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>O primeiro encontro com grupos</span>"
    ]
  },
  {
    "objectID": "estrut.html#sec-grupos",
    "href": "estrut.html#sec-grupos",
    "title": "4  O primeiro encontro com grupos",
    "section": "",
    "text": "GAP permite várias formas de definir grupos. O sistema já vem com algumas classes de grupos pré-definidas. Primeiro considere alguns exemplos usando os grupos GL e SL. Lembre que \\[\n\\mbox{GL}(n,\\mathbb F)=\\{A\\in M_{n\\times n}(\\mathbb F)\\mid \\det A\\neq 0\\}\n\\] e \\[\n\\mbox{SL}(n,\\mathbb F)=\\{A\\in \\mbox{GL}(n,\\mathbb F)\\mid \\det A\\neq 1\\}.\n\\] Quando \\(\\mathbb F\\) é o corpo finito com \\(q\\) elementos, o grupo \\(\\mbox{GL}(n,\\mathbb F)\\) e \\(\\mbox{SL}(n,\\mathbb F)\\) é também escrito como \\(\\mbox{GL}(n,q)\\) e \\(\\mbox{SL}(n,q)\\). Para revisar corpos finitos (função GF) consulte Seção 2.4.\ngap&gt; G1 := SL( 3, GF(5));\nSL(3,5)\ngap&gt; G1 := SL( 3, 5);\nSL(3,5)\ngap&gt; G1 := SL( 3, 5 );\nSL(3,5)\ngap&gt; G1 := GL( 3, 5 );\nGL(3,5)\ngap&gt; G2 := SL( 3, 5 );\nSL(3,5)\ngap&gt; Order( G1 );\n1488000\ngap&gt; Order( G2 );\n372000\ngap&gt; IsSubgroup( G1, G2 );\ntrue\ngap&gt; IsNormal( G1, G2 );\ntrue\nOra, considere construções com SymmetricGroup e AlternatingGroup. Lembre que o grupo simétrico \\(S_n\\) é o grupo de todas as permutações do conjunto \\(\\{1,\\ldots,n\\}\\) considerando com a operaçõo de composição. O grupo alternado \\(A_n\\) é o grupo das permutações pares.\ngap&gt; S6 := SymmetricGroup( 6 );\nSym( [ 1 .. 6 ] )\ngap&gt; A6 := AlternatingGroup( 6 );\nAlt( [ 1 .. 6 ] )\ngap&gt; IsSubgroup( S6, A6 );\ntrue\ngap&gt; IsNormal( S6, A6 );\ntrue\nNa biblioteca do GAP, tem uma base de dados com todos os grupos de ordem pequena. Estes grupos podem ser acessos usando a função SmallGroup( n, k ) que devolve o \\(k\\)-ésimo grupo de ordem \\(n\\) na biblioteca de GAP. Veja o seguinte exemplo.\ngap&gt; g := SmallGroup( 8, 3 );\n&lt;pc group of size 8 with 3 generators&gt;\ngap&gt; StructureDescription( g );\n\"D8\"\nO grupo SmallGroup( 8, 3 ) é o grupo diedral de ordem 8.\nUma família de grupos pode ser construído também com a função AllSmallGroups. No seguinte exemplo, vamos construir todos os grupos nilpotentes de ordem entre \\(10\\) e \\(20\\).\ngap&gt; AllSmallGroups( Size, [10..20] , IsNilpotent, true  );\n[ &lt;pc group of size 10 with 2 generators&gt;, \n  &lt;pc group of size 11 with 1 generator&gt;, \n  &lt;pc group of size 12 with 3 generators&gt;, \n  &lt;pc group of size 12 with 3 generators&gt;, \n  &lt;pc group of size 13 with 1 generator&gt;, \n  &lt;pc group of size 14 with 2 generators&gt;, \n  &lt;pc group of size 15 with 2 generators&gt;, \n  &lt;pc group of size 16 with 4 generators&gt;, \n  &lt;pc group of size 16 with 4 generators&gt;, \n  &lt;pc group of size 16 with 4 generators&gt;, \n  &lt;pc group of size 16 with 4 generators&gt;, \n  &lt;pc group of size 16 with 4 generators&gt;, \n  &lt;pc group of size 16 with 4 generators&gt;, \n  &lt;pc group of size 16 with 4 generators&gt;, \n  &lt;pc group of size 16 with 4 generators&gt;, \n  &lt;pc group of size 16 with 4 generators&gt;, \n  &lt;pc group of size 16 with 4 generators&gt;, \n  &lt;pc group of size 16 with 4 generators&gt;, \n  &lt;pc group of size 16 with 4 generators&gt;, \n  &lt;pc group of size 16 with 4 generators&gt;, \n  &lt;pc group of size 16 with 4 generators&gt;, \n  &lt;pc group of size 17 with 1 generator&gt;, \n  &lt;pc group of size 18 with 3 generators&gt;, \n  &lt;pc group of size 18 with 3 generators&gt;, \n  &lt;pc group of size 19 with 1 generator&gt;, \n  &lt;pc group of size 20 with 3 generators&gt;, \n  &lt;pc group of size 20 with 3 generators&gt; ]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>O primeiro encontro com grupos</span>"
    ]
  },
  {
    "objectID": "estrut.html#grupos-gerados-por-permutações",
    "href": "estrut.html#grupos-gerados-por-permutações",
    "title": "4  O primeiro encontro com grupos",
    "section": "4.2 Grupos gerados por permutações",
    "text": "4.2 Grupos gerados por permutações\n\nPode também definir grupo por geradores. Os geradores podem ser objetos multiplicáveis, tipicamente usamos matrizes e permutações. Primeiro, consideremos alguns exemplos com permutações.\ngap&gt; G := Group( (1,2), (1,2,3,4,5));\nGroup([ (1,2), (1,2,3,4,5) ])\ngap&gt; Size( G );\n120\ngap&gt; G = SymmetricGroup( 5 );\ntrue\ngap&gt; A := Group( (1,2,3),(3,4,5));\nGroup([ (1,2,3), (3,4,5) ])\ngap&gt; Size( A );\n60\ngap&gt; A = AlternatingGroup( 5 );\ntrue\ngap&gt; A = SymmetricGroup( 5 );\nfalse\nO grupo dihedral \\(D_5\\) de ordem \\(10\\) pode ser construído da forma seguinte.\ngap&gt; D := Group( (1,2,3,4,5),(2,5)(3,4));\nGroup([ (1,2,3,4,5), (2,5)(3,4) ])\ngap&gt; Size( D );\n10\ngap&gt; Elements( D );\n[ (), (2,5)(3,4), (1,2)(3,5), (1,2,3,4,5), (1,3)(4,5), (1,3,5,2,4), (1,4)(2,3), (1,4,2,5,3), (1,5,4,3,2), (1,5)(2,4) ]\ngap&gt; IsSubgroup( AlternatingGroup( 5 ), D );\ntrue\ngap&gt; IsNormal( AlternatingGroup( 5 ), D );\nfalse",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>O primeiro encontro com grupos</span>"
    ]
  },
  {
    "objectID": "estrut.html#grupos-gerados-por-matrizes",
    "href": "estrut.html#grupos-gerados-por-matrizes",
    "title": "4  O primeiro encontro com grupos",
    "section": "4.3 Grupos gerados por matrizes",
    "text": "4.3 Grupos gerados por matrizes\n\nPode-se também definir grupos de matrizes usando geradores. Considere por exemplo as seguintes duas matrizes sobre GF( 5 ): \\[\nm_1 = \\begin{pmatrix} 2 & 0 \\\\ 0 & 1 \\end{pmatrix}\\quad \\mbox{e}\\quad m_2 = \\begin{pmatrix} 2 & 1 \\\\ 2 & 0 \\end{pmatrix}.\n\\] O grupo gerado por \\(m_1\\) e \\(m_2\\) pode ser construído em GAP usando as seguintes instruções.\ngap&gt; m1 := [[2,0],[0,1]]*Z(5)^0;\n[ [ Z(5), 0*Z(5) ], [ 0*Z(5), Z(5)^0 ] ]\ngap&gt; m2 := [[2,1],[2,0]]*Z(5)^0;\n[ [ Z(5), Z(5)^0 ], [ Z(5), 0*Z(5) ] ]\ngap&gt; G := Group( m1, m2 );\nGroup([ [ [ Z(5), 0*Z(5) ], [ 0*Z(5), Z(5)^0 ] ], \n  [ [ Z(5), Z(5)^0 ], [ Z(5), 0*Z(5) ] ] ])\ngap&gt; Order( G );\n480\ngap&gt; G = GL( 2, 5 );\ntrue",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>O primeiro encontro com grupos</span>"
    ]
  },
  {
    "objectID": "estrut.html#tarefa-o-grupo-de-heisenberg",
    "href": "estrut.html#tarefa-o-grupo-de-heisenberg",
    "title": "4  O primeiro encontro com grupos",
    "section": "4.4 Tarefa: O grupo de Heisenberg",
    "text": "4.4 Tarefa: O grupo de Heisenberg\n\nSobre um corpo \\(\\mathbb F\\), o grupo de Heisenberg é o grupo \\[\nH=\\left\\{\\begin{pmatrix} 1 & a & c \\\\ 0 & 1 & b \\\\ 0 & 0 & 1\\end{pmatrix}\\mid a, b, c \\in\\mathbb F\\right\\}.\n\\]\nO seguinte resultado é fácil de verificar.\n\nSe \\(\\mathbb F\\) é um corpo finito de ordem \\(q\\), então \\(|H|=q^3\\).\n\n\nConstrua em GAP o grupo de Heisenberg sobre os corpos GF(2), GF(3), GF(5), GF( 9 ), GF( 25 ) como um grupo de matrizes dado por geradores. Calcule a ordem do grupo construido para verificar que tem o grupo certo.\nEscreva uma função heisenberg_group( q ) que devolve o grupo de Heisenberg sobre GF( q ) dado input q. A sua função precisa seguir o seguinte exemplo.\n\ngap&gt; H := heisenberg_group( 5 );\nGroup(\n[ \n  [ [ Z(5)^0, Z(5)^0, 0*Z(5) ], [ 0*Z(5), Z(5)^0, 0*Z(5) ], \n      [ 0*Z(5), 0*Z(5), Z(5)^0 ] ], \n  [ [ Z(5)^0, 0*Z(5), 0*Z(5) ], [ 0*Z(5), Z(5)^0, Z(5)^0 ], \n      [ 0*Z(5), 0*Z(5), Z(5)^0 ] ] ])\ngap&gt; Order( H );\n125\ngap&gt; H := heisenberg_group( 7 );\nGroup(\n[ \n  [ [ Z(7)^0, Z(7)^0, 0*Z(7) ], [ 0*Z(7), Z(7)^0, 0*Z(7) ], \n      [ 0*Z(7), 0*Z(7), Z(7)^0 ] ], \n  [ [ Z(7)^0, 0*Z(7), 0*Z(7) ], [ 0*Z(7), Z(7)^0, Z(7)^0 ], \n      [ 0*Z(7), 0*Z(7), Z(7)^0 ] ] ])\ngap&gt; Order( H );\n343\ngap&gt; H := heisenberg_group( 4 );\n&lt;matrix group of size 729 with 4 generators&gt;\ngap&gt; Order( H );\n729\n\nInvestiga o grupo de Heisenberg usando a sua função construída em cima. Calcule o seu centro, subgrupo derivado, os termos da série derivada, série central superior, e série central inferior.\n\n\n\nO grupo de Heisenberg \\(H\\) é gerado por dois geradores sobre o corpo \\(\\mathbb F_p\\). Sobre um corpo \\(\\mathbb F_{p^k}\\) o grupo é gerado por \\(2k\\) geradores. Para revisar como trabalhar sobre corpos finitos, consulte Seção 2.4; para ver como escrever uma função, consulte Seção 5.5.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>O primeiro encontro com grupos</span>"
    ]
  },
  {
    "objectID": "ling.html",
    "href": "ling.html",
    "title": "5  A linguagem de programação",
    "section": "",
    "text": "5.1 Expressões if-then-else",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A linguagem de programação</span>"
    ]
  },
  {
    "objectID": "ling.html#sec-if",
    "href": "ling.html#sec-if",
    "title": "5  A linguagem de programação",
    "section": "",
    "text": "A expressão if-then (manula) está usada quando queremos executar instruções de acordo com alguma condição que pode ser verdadeira ou falsa (Seção 2.2). Considere o seguinte exemplo:\ngap&gt; a := 3;                # seja a inicialmente 3\n3\ngap&gt; if a mod 2 = 0 then    # se a for par, dividimos a por 2\n&gt; b := a/2;\n&gt; fi;\ngap&gt; a;                     # valor de a continua 3\n3\ngap&gt; if a mod 2 = 1 then    # se a for ímpar, multiplicamos a por 3 e somamos 1\n&gt; a := 3*a+1;\n&gt; fi;\ngap&gt; a;                     # o valor de a mudou\n10\nExpressões mais complicadas podem ser montadas usando as palavras chaves else e elif.\ngap&gt; a := 3;\n3\ngap&gt; if a mod 2 = 0 then \n&gt; a := a/2;\n&gt; else\n&gt; a := 3*a+1;\n&gt; fi;\ngap&gt; a;\n10\ngap&gt; a := 8;\n8\ngap&gt; if a mod 2 = 0 then\n&gt; a := a/2;\n&gt; elif a mod 2 = 1 then \n&gt; a := 3*a+1;\n&gt; else\n&gt; a := -2\n&gt; fi;\ngap&gt; a;\n4",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A linguagem de programação</span>"
    ]
  },
  {
    "objectID": "ling.html#sec-for",
    "href": "ling.html#sec-for",
    "title": "5  A linguagem de programação",
    "section": "5.2 Laço for",
    "text": "5.2 Laço for\n\nUsamos for quando queremos executar a mesma peça de código várias vezes (manual). Por exemplo, queremos calcular o quadrado dos números entre 1 e 10.\ngap&gt; for i in [1..10] do\n&gt; Print( \"O quadrado de \", i, \" é \", i^2, \"\\n\" );\n&gt; od;\nO quadrado de 1 é 1\nO quadrado de 2 é 4\nO quadrado de 3 é 9\nO quadrado de 4 é 16\nO quadrado de 5 é 25\nO quadrado de 6 é 36\nO quadrado de 7 é 49\nO quadrado de 8 é 64\nO quadrado de 9 é 81\nO quadrado de 10 é 100\nObservamos os seguintes regras importantes:\n\na palavra chave for é seguida por uma variável, neste caso i;\ndepois temos a palavra in seguida por uma lista (Seção 3.1);\ndepois da lista temos a palavra do;\no laço está fechado pela palavra od (do reverso).\n\nO ciclo executa o código entre as palavras do e od para todo valor i na lista que aparece depois da palavra in.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A linguagem de programação</span>"
    ]
  },
  {
    "objectID": "ling.html#sec-while",
    "href": "ling.html#sec-while",
    "title": "5  A linguagem de programação",
    "section": "5.3 Laço while",
    "text": "5.3 Laço while\n\nUma outra maneira de criar um laço é usar a construção com while (manual). Considere o seguinte exemplo.\ngap&gt; while i &lt;= 10 do \n&gt; Print( \"O quadrado de \", i, \" é \", i^2, \"\\n\" );\n&gt; i := i + 1;\n&gt; od;\nO quadrado de 0 é 0\nO quadrado de 1 é 1\nO quadrado de 2 é 4\nO quadrado de 3 é 9\nO quadrado de 4 é 16\nO quadrado de 5 é 25\nO quadrado de 6 é 36\nO quadrado de 7 é 49\nO quadrado de 8 é 64\nO quadrado de 9 é 81\nO quadrado de 10 é 100\nAs regras de construir este tipo de laço são as seguintes:\n\na palavra while (enquanto) está seguida por uma condição lógica (booleana) e depois pela palavra do;\no laço está fechado pela palavra od;\na peça de código está executado entre as palavras do e od enquanto (while) a condição está verdadeira (Seção 2.2).\n\nNote que no laço while o valor da variável i precisa ser incrementado manualmente.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A linguagem de programação</span>"
    ]
  },
  {
    "objectID": "ling.html#sec-repeat",
    "href": "ling.html#sec-repeat",
    "title": "5  A linguagem de programação",
    "section": "5.4 Laço repeat",
    "text": "5.4 Laço repeat\n\nO terceiro tipo de laço pode ser construída com a palavra repeat (manual). Considere o seguinte exemplo:\ngap&gt; i := 0;\n0\ngap&gt; repeat\n&gt; Print( \"O quadrado de \", i, \" é \", i^2, \"\\n\" );\n&gt; i := i + 1;\n&gt; until i = 10;\nO quadrado de 0 é 0\nO quadrado de 1 é 1\nO quadrado de 2 é 4\nO quadrado de 3 é 9\nO quadrado de 4 é 16\nO quadrado de 5 é 25\nO quadrado de 6 é 36\nO quadrado de 7 é 49\nO quadrado de 8 é 64\nO quadrado de 9 é 81\nObservamos que\n\nO laço está iniciado pela palavra repeat;\nna última linha, temos a palavra until seguida por uma condição lógica;\no sistema termina a execução do laço assim que a condição depois de repeat vira verdadeira (Seção 2.2).\n\nA diferença entre os laços construídos por while e repeat é que no caso de while a decisão está feita antes da execução do código, enquanto no caso de repeata mesma decisão está feita depois da execução. Em particular, o laço repeat sempre será executado pelo menos uma vez. Considere o seguinte código e explique o comportamento.\ngap&gt; i := 11;\n11\ngap&gt; while i &lt;= 10 do\n&gt; Print( \"O quadrado de \", i, \" é \", i^2, \"\\n\" );\n&gt; i := i + 1;\n&gt; od;\n\ngap&gt; i := 11;\n11\ngap&gt; repeat\n&gt; Print( \"O quadrado de \", i, \" é \", i^2, \"\\n\" );\n&gt; i := 11;\n&gt; until i &gt;= 10;\nO quadrado de 11 é 121",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A linguagem de programação</span>"
    ]
  },
  {
    "objectID": "ling.html#sec-functions",
    "href": "ling.html#sec-functions",
    "title": "5  A linguagem de programação",
    "section": "5.5 Funções",
    "text": "5.5 Funções\n\nFunções em GAP podem ser usadas para realizar computações que queremos fazer várias vezes com diferentes objetos. Por exemplo a função que, dado x computa 3*x+1 pode ser definida de duas maneiras diferentes.\ngap&gt; f1 := function( x )\n&gt; return 3*x+1;\n&gt; end;\nfunction( x ) ... end\ngap&gt; f1( 5 );\n16\nObserve que o valor da função é devolvido pela expressão return.\ngap&gt; f2 := x -&gt; 3*x + 1;\nfunction( x ) ... end\ngap&gt; f2( -2 );\n-5\ngap&gt; f1 = f2;\nfalse\n# As funções f1 e f2 fazem a mesma coisa, mas são objetos distintos\nNos exemplos anteriores, a função não precisa de variáveis adicionais para executar sua tarefa. Isso pode acontecer com funções simples, mas uma função mais complicada pode precisar introduzir as suas próprias variáveis, chamadas de variáveis locais. Considere a seguinte implementação do exemplo em cima.\ngap&gt; f3 := function( x )\n&gt; local y;\n&gt; y := 3*x;\n&gt; return y+1;\n&gt; end;\nfunction( x ) ... end\ngap&gt; f3(4);\n13\ngap&gt; y;\nError, Variable: 'y' must have a value\nnot in any function at *stdin*:44\nAs últimas linhas do exemplo anterior mostram que o variável y não está visível fora da função. Isso permite que variáveis com o mesmo nome sejam usadas em várias funções sem que sejam confundidas. O mesmo também impede que a varíavel local y definida dentro da função f3 seja confundida com uma possível variável global também chamada de y. O seguinte código mostra que o nome y tem significado diferente dentro e fora da função.\ngap&gt; f3 := function( x )\n&gt; local y;\n&gt; y := 3*x;\n&gt; Print( \"O valor de y é \", y, \"\\n\" );\n&gt; return y+1;\n&gt; end;\nfunction( x ) ... end\ngap&gt; y := -5;\n-5\ngap&gt; f3(10);\nO valor de y é 30\n31\ngap&gt; y;\n-5\nFunções podem receber mais que um argumento. Considere o seguinte exemplo.\ngap&gt; my_sum := function( x, y )\n&gt; return x+y;\n&gt; end;\nfunction( x, y ) ... end\ngap&gt; my_sum( 4, -1 );\n3\nGAP permite também um número varíavel de argumentos como no seguinte exemplo.\ngap&gt; f4 := function( a, args... )\n&gt; local b;\n&gt; if Length( args ) &gt;  0 then\n&gt; b := args[1];\n&gt; else\n&gt; b := true;\n&gt; fi;\n&gt; if b then\n&gt; return 3*a-1;\n&gt; else\n&gt; return a/2;\n&gt; fi;\n&gt; end;\nfunction( a, args... ) ... end\nEsta função devolve \\(3a-1\\) se tem apenas um argumento. No entanto, o usuário pode fornecer um segundo argumento que pode ser true ou false. No caso de true, a função devolve \\(3a-1\\), mas no caso de false, a função devolve \\(a/2\\).\ngap&gt; f4(4);\n11\ngap&gt; f4(3);\n8\ngap&gt; f4(3, true);\n8\ngap&gt; f4(3, false);\n3/2\ngap&gt; f4(4, false);\n2",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A linguagem de programação</span>"
    ]
  },
  {
    "objectID": "ling.html#sec-break-continue",
    "href": "ling.html#sec-break-continue",
    "title": "5  A linguagem de programação",
    "section": "5.6 Break e continue",
    "text": "5.6 Break e continue\n\nAs expressões break (manual e continue (manual) podem ser usadas em laços.\nQuando a expressão break está executada, o sistema sai do laço. No caso de continue, o sistema sai da iteração atual e passa para a próxima iteração.\ngap&gt; for i in [1..10] do\n&gt; if i = 5 then break; fi;\n&gt; Print( i, \"\\n\" );\n&gt; od;\n1\n2\n3\n4\ngap&gt; for i in [1..10] do\n&gt; if i = 5 then continue; fi;\n&gt; Print( i, \"\\n\" );\n&gt; od;\n1\n2\n3\n4\n6\n7\n8\n9\n10",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A linguagem de programação</span>"
    ]
  },
  {
    "objectID": "erdos_woods.html",
    "href": "erdos_woods.html",
    "title": "6  Os números de Erdős-Woods",
    "section": "",
    "text": "6.1 Os números",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Os números de Erdős-Woods</span>"
    ]
  },
  {
    "objectID": "erdos_woods.html#os-números",
    "href": "erdos_woods.html#os-números",
    "title": "6  Os números de Erdős-Woods",
    "section": "",
    "text": "Um intervalo de números naturais \\(\\{a,a+1,\\ldots,a+k\\}\\) chama-se intervalo de Erdős-Woods, se todo número \\(m\\in\\{a,a+1,\\ldots,a+k\\}\\) tem algum fator comum ou com \\(a\\) ou com \\(a+k\\). Por exemplo, o intervalo \\[\n\\{5,6,7,8,9\\}\n\\] não é de Erdős-Woods, pois \\(7\\) é coprimo com \\(5\\) e também com \\(9\\). Um número natural \\(k\\in\\mathbb N\\) é dito número de Erdős-Woods (veja também na OEIS), se existe um intervalo de Erdős-Woods com comprimento \\(k\\). Por exemplo, \\(2\\) não é número de Erdős-Woods, pois no intervalo \\(\\{a,a+1,a+2\\}\\) o número \\(a+1\\) é coprimo com \\(a\\) e também com \\(a+2\\).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Os números de Erdős-Woods</span>"
    ]
  },
  {
    "objectID": "erdos_woods.html#exploração-interativa",
    "href": "erdos_woods.html#exploração-interativa",
    "title": "6  Os números de Erdős-Woods",
    "section": "6.2 Exploração interativa",
    "text": "6.2 Exploração interativa\n\nVamos verificar por exemplo que \\(\\{10,11,12,13,14,15\\}\\) não é de Erdős-Woods.\ngap&gt; a := 10; k := 5;\n10\n5\ngap&gt; Filtered( [a..a+k], x-&gt; GcdInt( a, x ) = 1 and GcdInt( a+k,x) = 1 );\n[ 11, 13 ]\nOu seja, os números \\(11\\) e \\(13\\) são coprimos com o início e com o final do intervalo.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Os números de Erdős-Woods</span>"
    ]
  },
  {
    "objectID": "erdos_woods.html#tarefa",
    "href": "erdos_woods.html#tarefa",
    "title": "6  Os números de Erdős-Woods",
    "section": "6.3 Tarefa",
    "text": "6.3 Tarefa\n\n\nEscreva uma função is_Erdős_woods_interval( a, k ) que verifica se o intervalo \\(\\{a,a+1,\\ldots,a+k\\}\\) é de Erdős-Woods. A função deve devolver true ou false dependendo se o intervalo é de Erdős-Woods. A sua função deve funcionar na seguinte forma.\n\ngap&gt; is_ew_interval( 10,5 );\nfalse\ngap&gt; is_ew_interval( 13,4 );\nfalse\n\nUse a função escrito no item anterior para verificar que os números \\(16\\) e \\(22\\) são de Erdős-Woods. Ache os intervalos que testemunham que estes números são de fato de Erdős-Woods.\nConsegue achar mais números de Erdős-Woods?\n\n\n\nPara verificar um intervalo, pode usar Filtered como no exemplo anterior ou o laço for (Seção 5.2) e a função GcdInt (manual) dentro do laço. .\n\nEste projeto foi inspirado pelo seguinte vídeo.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Os números de Erdős-Woods</span>"
    ]
  },
  {
    "objectID": "collatz.html",
    "href": "collatz.html",
    "title": "7  A conjetura de Collatz",
    "section": "",
    "text": "7.1 A Conjetura de Collatz\n\\(\\newcommand{\\N}{\\mathbb N}\\)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A conjetura de Collatz</span>"
    ]
  },
  {
    "objectID": "collatz.html#a-conjetura-de-collatz",
    "href": "collatz.html#a-conjetura-de-collatz",
    "title": "7  A conjetura de Collatz",
    "section": "",
    "text": "Considere a seguinte função \\(f:\\N\\to \\N\\): \\[\n    f(n)=\\left\\{\\begin{array}{cc} n/2 & \\mbox{se $n$ for par;}\\\\\n    3n+1 & \\mbox{se $n$ for ímpar.}\\end{array}\\right.\n\\] A Conjetura de Collatz afirma que para todo \\(n\\in\\N\\), existe um número \\(k\\) tal que aplicando a função \\(f\\) consecutivamente \\(k\\) vezes em \\(n\\), o resultado vai ser igual a \\(1\\). Em outras, palavras, \\(f^k(n)=1\\).",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A conjetura de Collatz</span>"
    ]
  },
  {
    "objectID": "collatz.html#tarefa-1",
    "href": "collatz.html#tarefa-1",
    "title": "7  A conjetura de Collatz",
    "section": "7.2 Tarefa 1",
    "text": "7.2 Tarefa 1\n\nEscreva uma função collatz( n ) que toma \\(n\\) como input e devolve \\(f(n)\\). Faça testes da sua função com vários números.\nA sua função deve comportar-se de acordo com os seguintes exemplos:\ngap&gt; collatz( 15 );\n46\ngap&gt; collatz( 14 );\n7\ngap&gt; collatz( 5 );\n16\n\n\nPrecisa testar, usando if, (Seção 5.1) se o input é par ou ímpar e para isso pode usar a operação mod (Seção 2.1). Se precisar de ajuda com funções, consulte a Seção 5.5.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A conjetura de Collatz</span>"
    ]
  },
  {
    "objectID": "collatz.html#tarefa-2",
    "href": "collatz.html#tarefa-2",
    "title": "7  A conjetura de Collatz",
    "section": "7.3 Tarefa 2",
    "text": "7.3 Tarefa 2\n\nEscreva uma função nr_steps( n ) que vai calcular o número de vezes a função \\(f\\) precisa ser aplicada em \\(n\\) para obter o número \\(1\\). Em outras palavras, nr_steps( n ) deve devolver o menor número \\(k\\) tal que \\(f^k(n)=1\\). Para \\(n=1\\), nós vamos assumir que \\(f^0(1)=1\\).\nA sua função precisa devolver o resultado de acordo com os seguintes exemplos.\ngap&gt; nr_steps( 1 );\n0\ngap&gt; nr_steps( 3 );\n7\ngap&gt; nr_steps( 14 );\n17\ngap&gt; nr_steps( 32 );\n5\n\n\n\nVocê usará a função collatz( n ) na tarefa anterior em um laço while (Seção 5.3) ou repeat (Seção 5.4). Vai precisar também de variável local (explicado na Seção 5.5).",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A conjetura de Collatz</span>"
    ]
  },
  {
    "objectID": "collatz.html#tarefa-3",
    "href": "collatz.html#tarefa-3",
    "title": "7  A conjetura de Collatz",
    "section": "7.4 Tarefa 3",
    "text": "7.4 Tarefa 3\n\nEscreva uma função max_nr_steps( n ) para determinar o número \\(k\\) tal que nr_steps( k ) é maior possível para os números \\(k\\in\\{1,\\ldots,n\\}\\). A função deve devolver uma lista (Seção 3.1) de comprimento \\(2\\) tal que a primeira entrada da lista é o número \\(k\\) e a segunda é o número nr_steps( k ).\nO comportamento da sua função seguirá os seguintes exemplos:\ngap&gt; max_nr_steps( 1000 );\n[ 871, 178 ]\ngap&gt; max_nr_steps( 10000 );\n[ 6171, 261 ]\ngap&gt; max_nr_steps( 100000 );\n[ 77031, 350 ]\n\n\n\nPode usar a função nr_steps( k ) escrita na tarefa anterior em um laço for (Seção 5.2) que roda na lista [1..n].",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A conjetura de Collatz</span>"
    ]
  },
  {
    "objectID": "collatz.html#tarefa-4",
    "href": "collatz.html#tarefa-4",
    "title": "7  A conjetura de Collatz",
    "section": "7.5 Tarefa 4",
    "text": "7.5 Tarefa 4\n\nVamos otimizar o código que foi escrito para a Tarefa 3. Calcular nr_steps( k ) separadamente para todo \\(k\\in \\{1,\\ldots,n\\}\\) faz muita computação redundante. Por exemplo, calculando max_nr_steps( 6 ) deste jeito, fazemos as seguintes contas\n1 → 1 \n2 → 1\n3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 \n4 → 2 → 1 \n5 → 16 → 8 → 4 → 2 → 1\n6 → 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1\nA computação nr_steps( 6 ) deve realizar que nr_steps( 3 ) já foi calculado e simplificar a conta por computar que nr_steps( 6 ) = nr_steps( 3 ) + 1. Escreva uma versão da função max_nr_steps_fast( n ) utilizando as computações anteriores e compare o tempo de execução das duas versões.\nDe acordo com o seguinte exemplo, calcular o valor maximal de nr_steps( k ) para k in [1..1000000] demora mais que 25 segundos usando a função escrita para a Tarefa 3. A nova função faz esta computação em apenas 1,3 segundos.\ngap&gt; max_nr_steps( 1000000 ); time;   \n[ 837799, 524 ]\n25391\ngap&gt; max_nr_steps_fast( 1000000 ); time;\n[ 837799, 524 ]\n1335\n\n\nDenotando por \\(k_n\\) o valor da função nr_steps( n ), guarde o valor de \\(k_n\\) como o \\(k\\)-ésima entrada em uma lista. A lista pode ser uma lista esparsa (Seção 3.1). Provavelmente precisará das expressões break e continue (Seção 5.6). Pode usar também a variável interna time que devolve o tempo (em milisegundos) que a última instrução tomou (manual).",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>A conjetura de Collatz</span>"
    ]
  },
  {
    "objectID": "aliquot.html",
    "href": "aliquot.html",
    "title": "8  A sequência alíquota",
    "section": "",
    "text": "8.1 Tarefa 1",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A sequência alíquota</span>"
    ]
  },
  {
    "objectID": "aliquot.html#tarefa-1",
    "href": "aliquot.html#tarefa-1",
    "title": "8  A sequência alíquota",
    "section": "",
    "text": "Escreva uma função sum_divisors( n ) em GAP que dado um numero n devolve \\(\\sigma(n)\\). A sua função deve se comportar como no seguinte exemplo.\ngap&gt; sum_divisors( 8 );\n7\ngap&gt; sum_divisors( 9 );\n4\ngap&gt; sum_divisors( 11 );\n1\n\n\nPode usar as funções DivisorsInt (manual) e Sum (manual). Também pode precisar de if para decidir se n=0, pois DivisorsInt( 0 ) não funciona (Seção 5.1).",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A sequência alíquota</span>"
    ]
  },
  {
    "objectID": "aliquot.html#tarefa-2",
    "href": "aliquot.html#tarefa-2",
    "title": "8  A sequência alíquota",
    "section": "8.2 Tarefa 2",
    "text": "8.2 Tarefa 2\n\nUm número \\(n\\) chama-se perfeito se \\(\\sigma(n)=n\\).\n\nEscreva uma função is_perfect( n ) que devolva true se n é perfeito e false se n não é perfeito.\n\ngap&gt; is_perfect( 6 );\ntrue\ngap&gt; is_perfect( 20 );\nfalse\ngap&gt; is_perfect( 28 );\ntrue\n\nAche todos os números perfeitos entre 1 e 1000000.\nUm número \\(n\\) chama-se abundante, se \\(\\sigma(n)&gt;n\\). Escreva uma função is_abundant( n ) que devolve true se o número n é abundante e false se não é abundante.\nAche todos os números abundantes entre 1 e 1000.\n\n\n\nUse a funução sum_divisors escrita para a tarefa anterior. Se precisar, revise como trabalhar com valores booleanas (Seção 2.2).",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A sequência alíquota</span>"
    ]
  },
  {
    "objectID": "aliquot.html#tarefa-3",
    "href": "aliquot.html#tarefa-3",
    "title": "8  A sequência alíquota",
    "section": "8.3 Tarefa 3",
    "text": "8.3 Tarefa 3\n\nDois números \\(n\\) e \\(m\\) são chamados de amigáveis se \\(\\sigma(n)=m\\) e \\(\\sigma(m)=n\\).\n\nEscreva uma função is_friendly( n ) que verifica se um número n é membro de um par amigável. A função deve devolver o par de n caso sim, e 0 caso não.\n\ngap&gt; is_friendly( 6 );\n6\ngap&gt; is_friendly( 220 );\n284\ngap&gt; is_friendly( 284 );\n220\ngap&gt; is_friendly( 200 );\n0\n\nAche todos os pares amigáveis de números entre 1 e 1000000.\n\n\n\nUse a função sum_divisors escrita para Tarefa 1. Pode usar também a função Filtered sobre [1..1000000] (Seção 3.1).",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A sequência alíquota</span>"
    ]
  },
  {
    "objectID": "aliquot.html#tarefa-4",
    "href": "aliquot.html#tarefa-4",
    "title": "8  A sequência alíquota",
    "section": "8.4 Tarefa 4",
    "text": "8.4 Tarefa 4\n\nSeja \\(a_0\\in\\mathbb N\\) arbitrário. Defina a sequência que começa por \\(a_0\\) e para \\(i\\geq 1\\), \\(a_i=\\sigma(a_{i-1})\\). Por exemplo, se \\(a_0=8\\), então \\[\na_0=8,\\quad a_1=\\sigma(8)=7,\\quad a_2=\\sigma(7)=1, a_3=\\sigma(1)=0, \\quad a_4=\\sigma(0)=0.\n\\] Este tipo de sequência chama-se sequência alíquota (aliquot sequence).\n\nEscreva uma função aliquot_sequence( a0, k ) que, dado a0 e um número k, devolve os primeiros k termos da sequência alíquota que inicia-se com a0.\n\ngap&gt; aliquot_sequence( 8, 4 );\n[ 8, 7, 1, 0 ]\ngap&gt; aliquot_sequence( 24, 6 );\n[ 24, 36, 55, 17, 1, 0 ]\ngap&gt; aliquot_sequence( 30, 15 );\n[ 30, 42, 54, 66, 78, 90, 144, 259, 45, 33, 15, 9, 4, 3, 1 ]\n\nModifique a sua função em tal forma que a execução termina assim que a sequẽncia vira periódica.\n\ngap&gt; aliquot_sequence_until_repeat( 21 );\n[ 21, 11, 1, 0, 0 ]\ngap&gt; aliquot_sequence_until_repeat( 42 );\n[ 42, 54, 66, 78, 90, 144, 259, 45, 33, 15, 9, 4, 3, 1, 0, 0 ]\ngap&gt; aliquot_sequence_until_repeat( 34 );\n[ 34, 20, 22, 14, 10, 8, 7, 1, 0, 0 ]\n\nO comprimento da sequência é o número de passos que precisamos fazer até a sequência vira periódica. Ache o números entre \\(1\\) e \\(1000\\) que produzem o sequência particularmente longas.\n\n\n\nAlém de utulizar a função sum_divisors, vai precisar de listas (Seção 3.1), variáveis locais (Seção 5.5), e laços (Seção 5.2 e Seção 5.3). Pode precisar também a expressão break (Seção 5.6).\n\nEste projeto foi inspirado pelo seguinte vídeo.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>A sequência alíquota</span>"
    ]
  },
  {
    "objectID": "rsa.html",
    "href": "rsa.html",
    "title": "Criptografia RSA",
    "section": "",
    "text": "A criprografia RSA",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Criptografia RSA</span>"
    ]
  },
  {
    "objectID": "rsa.html#a-criprografia-rsa",
    "href": "rsa.html#a-criprografia-rsa",
    "title": "Criptografia RSA",
    "section": "",
    "text": "Na área da criptografia, a suposição geral é que dois parceiros (que podem ser duas pessoas, ou dois computadores) querem trocar informação sigilosa usando um canal de comunicação que está disponível para terceiros. Os dois parceiros geralmente chamam-se A(lice) e B(ob) e um possível terceiro chama-se E(va). Assume-se que as mensagens enviadas por Alice e Bob são números. A Eva consegue interceptar as mensagens enviadas. O objetivo é desenvolver métodos seguros de criptografia para as mensagens que podem garantir que Eva não vai conseguir descriptografar as mensagens mesmo conseguindo interceptadá-las.\nUm método, conhecido como criptografia RSA, foi desenvolvido pelos matemáticos Ron Rivest, Adi Shamir, and Leonard Adleman e foi publicado em 1977.\nLembre que a função \\(\\varphi\\) de Euler é definida como \\[\n\\varphi(n)=|\\{a\\in\\{1,\\ldots,n\\}\\mid \\mbox{mdc}(a,n)=1\\}|\n\\] para todo natural \\(n\\). Temos, para primos \\(p\\) e \\(q\\) distintos, que \\[\n\\varphi(pq)=(p-1)(q-1).\n\\]\nAssuma que Alice quer enviar uma mensagem para Bob. Eles seguem os seguintes passos:\n\nBob escolhe um número \\(n\\) tal que \\(n\\) é produto de dois primos \\(p\\) e \\(q\\) e escolhe um número \\(c\\in\\{2,\\ldots,n-1\\}\\) tal que \\(\\mbox{mdc}(c,\\varphi(n))=1\\). Isso implica que \\(c\\) é invertível módulo \\(\\varphi(n)\\); ou seja existe \\(d\\in\\{1,\\ldots,\\varphi(n)\\}\\) tal que \\[\ncd\\equiv 1\\pmod{\\varphi(n)}.\n\\]\nBob publica o par \\((n,c)\\) dos números. Este é a chave pública do Bob e está disponível publicamente para toda pessoa que quer enviar mensagem sigilosa para o Bob. Em particular esta chave é conhecida por Alice.\nO Bob guarda os números \\((\\varphi(n),d)\\) em sigilo. Esta é a chave privada do Bob.\nA mensagem da Alice é um número \\(b\\) entre \\(1\\) e \\(n\\). A Alice vai calcular \\[\nC(b)=\\mbox{o resto de $b^c$ por $n$}.\n\\] Note que Alice conhece os números \\(c\\) e \\(n\\) e consegue calcular \\(C(b)\\). O número \\(C(b)\\) é a mensagem criptografada.\nAlice envia \\(C(b)\\) para o Bob.\nAo receber a mensagem \\(b_1=C(b)\\) da Alice, Bob calcula \\[\nD( b_1)=\\mbox{o resto de $b_1^c$ módulo $n$}.\n\\] O número obtido \\(D(b_1)\\) é a mensagem descriptografada.\nO número \\(D(b_1)\\) coincide com a mensagem original \\(b\\) da Alice; ou seja, o Bob conseguiu descriptografar a mensagem da Alice.\n\n\nTeorema 9.1 Usando a notação acima, \\(D(C(b))=b\\) para todo \\(b\\in\\{1,\\ldots,n-1\\}\\). Ou seja, usando a função \\(D\\), o Bob consegue descodificar a mensagem da Alice",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Criptografia RSA</span>"
    ]
  },
  {
    "objectID": "rsa.html#exploração-interativa",
    "href": "rsa.html#exploração-interativa",
    "title": "Criptografia RSA",
    "section": "Exploração interativa",
    "text": "Exploração interativa\n\nAssuma que trabalhamos com um protocolo simplificado; ou seja, vamos criar um protocolo de criptografia de 100 bits (digitos binários). Usando NextPrimeInt ache dois primos pe q tal que o produto é um numero composto entre \\(2^{99}\\) e \\(2^{100}-1\\). Por motivos de segurança, é recomendável que os primos p e q não sejam próximos, mas também não queremos que um deles seja pequeno. Nós vamos atingir este critério por escolher o primo p com 60 bits, enquanto o primo q terá de 40 bits.\ngap&gt; p := NextPrimeInt( Random( 2^59, 2^60 ));\n1086726084099436427\ngap&gt; q := NextPrimeInt( Random( 2^39, 2^40 ));\n1073930166469\ngap&gt; n := p*q;\n1167067924403112255997192566263\ngap&gt; n &lt;= 2^100;\ntrue\nNote que na sua computação você vai obter primos diferentes, pois os primos obtidos são aleatórios.\nVamos criar as chaves \\(c\\) e \\(d\\) em dois métodos diferentes. Primeiro usamos aritmética ingegral calculando MDC.\nPara criar as chaves \\(c\\) e \\(d\\), usaremos aritmética modular. Vamos criar os anéis \\(R\\) e \\(R_1\\) de classes residuais módulo \\(n\\) e calcular \\(\\varphi(n)=(p-1)(q-1)\\).\ngap&gt; phi_n := (p-1)*(q-1);\n1167067924402025528839162963368\ngap&gt; c := Random( 2, phi_n );\n176805719378978229840699134270\ngap&gt; gcd_rec := Gcdex( c, phi_n );\nrec( coeff1 := 79157182339546985315507365253, \n  coeff2 := -77535409344988357319333137017, \n  coeff3 := -194511320733670921473193827228, \n  coeff4 := 190526171214974642831565237209, gcd := 6 )\ngap&gt; c := Random( 2, phi_n );     \n1102805946491101901632051878773\ngap&gt; gcd_rec := Gcdex( c, phi_n );\nrec( coeff1 := -121794025824117152741759339875, \n  coeff2 := 115087710935716733897683004232, \n  coeff3 := 1167067924402025528839162963368, \n  coeff4 := -1102805946491101901632051878773, gcd := 1 )\ngap&gt; gcd_rec.coeff1*c + gcd_rec.coeff2*phi_n;\n1\ngap&gt; gcd_rec.coeff1*c mod phi_n;             \n1\ngap&gt; d := gcd_rec.coeff2;\n115087710935716733897683004232\ngap&gt; 2^c mod n;\nError, Integer operands: &lt;exponent&gt; is too large\nnot in any function at *stdin*:112\ntype 'quit;' to quit to outer loop\nbrk&gt; quit;\nNote que a expressão 2^1102805946491101901632051878773 não foi aceita pelo GAP, pois o expoente é muito grande. Para fazer esta conta, vamos utulizar anéis residuais.\ngap&gt; R := ZmodnZ( n );\n(Integers mod 1167067924403112255997192566263)\ngap&gt; R1 := ZmodnZ( (p-1)*(q-1) );\n(Integers mod 1167067924402025528839162963368)\ngap&gt; c := Random( R1 );\nZmodnZObj( 449601717067465409204371741486, 1167067924402025528839162963368 )\ngap&gt; IsUnit( c );\nfalse\ngap&gt; c := Random( R1 );\nZmodnZObj( 564525934207952237103150572399, 1167067924402025528839162963368 )\ngap&gt; IsUnit( c );\ntrue\ngap&gt; d := c^-1;\nZmodnZObj( 477861003212806940664702229055, 1167067924402025528839162963368 )\ngap&gt; c := Int( c );\n564525934207952237103150572399\ngap&gt; d := Int( d );\n477861003212806940664702229055\nTendo criado, estes números, assuma que temos uma mensagem a que é um número entre 2 e n. Vamos criptografar e descriptografar a mensagem.\ngap&gt; msg2 := 2*One( R );\nZmodnZObj( 2, 1167067924403112255997192566263 )\ngap&gt; msg2_cript := msg2^c;\nZmodnZObj( 409777624988356516250582182849, 1167067924403112255997192566263 )\ngap&gt; msg2_descript := msg2_cript^d;\nZmodnZObj( 2, 1167067924403112255997192566263 )\ngap&gt; msg_rand := Random( R );\nZmodnZObj( 417408283977422861261533080164, 1167067924403112255997192566263 )\ngap&gt; msg_rand_cript := msg_rand^c;\nZmodnZObj( 117680927883705414410064163455, 1167067924403112255997192566263 )\ngap&gt; msg_rand_descript := msg_rand_cript^d;\nZmodnZObj( 417408283977422861261533080164, 1167067924403112255997192566263 )\ngap&gt; msg_rand_descript = msg_rand;\ntrue\nNote que a criptografia criada neste exemplo não é segura, pois o número \\(n\\) pode ser fatorado (devido ao tamanho relativamente pequeno de fatores).\ngap&gt; Factors( n );\n[ 1073930166469, 1086726084099436427 ]",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Criptografia RSA</span>"
    ]
  },
  {
    "objectID": "rsa.html#tarefa-1",
    "href": "rsa.html#tarefa-1",
    "title": "Criptografia RSA",
    "section": "Tarefa 1",
    "text": "Tarefa 1\n\nRepita a computação anterior, mas agora com números maiores. Em vez de trabalhar com chave de comprimento de 100 bits, trabalhe com chave de 2048 bits que é o usual com protocolos modernos de criptografia RSA. O comprimento de p será de 1228 bits, enquanto o comprimento de q será de 820 bits. (Ou seja, p é um primo entre \\(2^{1227}\\) e \\(2^{1228}-1\\)) e q é primo entre \\(2^{819}\\) e \\(2^{820}-1\\).\nVerifique que o número \\(n\\) obtida desta vez não pode ser fatorado usando Factors( n ).\n\n\nÚnica coisa que precisa modificar é que a função NextPrimeInt não funciona para estes típos de números e precisa usar NextProbablyPrimeInt.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Criptografia RSA</span>"
    ]
  },
  {
    "objectID": "rsa.html#tarefa-2",
    "href": "rsa.html#tarefa-2",
    "title": "Criptografia RSA",
    "section": "Tarefa 2",
    "text": "Tarefa 2\n\nEscreva uma função RSA_keys( nr_bits ) que gera dados necessários para criptografia RSA usando nr_bits. Ou seja, RSA_keys( nr_bits ) devolve\n\no número n que é produto dos primos p e q (mas não devolve os números p e q);\ndevolve a chave pública c e a chave privada d.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Criptografia RSA</span>"
    ]
  },
  {
    "objectID": "commutators.html",
    "href": "commutators.html",
    "title": "10  Comutadores em grupos",
    "section": "",
    "text": "10.1 O problema",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Comutadores em grupos</span>"
    ]
  },
  {
    "objectID": "commutators.html#o-problema",
    "href": "commutators.html#o-problema",
    "title": "10  Comutadores em grupos",
    "section": "",
    "text": "Seja \\(G\\) um grupo. Se \\(x,y\\in G\\), o comutador \\([x,y]\\) está definido como \\[\n[x,y]=x^{-1}y^{-1}xy.\n\\] O subgrupo derivado \\(G'\\) de \\(G\\) é definido como o subgrupo de \\(G\\) gerado por todos os comutadores; ou seja, \\[\nG'=\\left&lt;[x,y]\\mid x,y\\in G\\right&gt;.\n\\] É importante observar que o subgrupo derivado por definição não é apenas o conjunto dos comutadores, mas ele é o subgrupo gerado por este conjunto. Isso é porque o conjunto de comutadores pode não ser um subgrupo. No entanto, nos grupos pequeno \\(G'\\) coincide com o conjunto de comutadores.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Comutadores em grupos</span>"
    ]
  },
  {
    "objectID": "commutators.html#exploração-interativa",
    "href": "commutators.html#exploração-interativa",
    "title": "10  Comutadores em grupos",
    "section": "10.2 Exploração interativa",
    "text": "10.2 Exploração interativa\n\nVamos explorar o conjunto de comutadores em um grupo dado. Considere por exemplo o grupo SymmetricGroup( 5 ). Vamos primeiro calcular o comutador de dois elementos.\ngap&gt; G := SymmetricGroup( 5 );\nSym( [ 1 .. 5 ] )\ngap&gt; x := (1,2,3,4,5);\n(1,2,3,4,5)\ngap&gt; y := (1,2);\n(1,2)\ngap&gt; x in G;\ntrue\ngap&gt; y in G;\ntrue\ngap&gt; Comm( x, y );\n(1,2,3)\ngap&gt; Comm( x, y ) = x^-1*y^-1*x*y;\ntrue\nOra, vamos computar o conjunto de comutadores de \\(G\\) e comparamos este conjunto com o subgrupo derivado.\ngap&gt; comms := Set( Tuples( Elements( G ), 2 ), t-&gt;Comm( t[1],t[2]));\n[ (), (3,4,5), (3,5,4), (2,3)(4,5), (2,3,4), (2,3,5), (2,4,3), (2,4,5), \n  (2,4)(3,5), (2,5,3), (2,5,4), (2,5)(3,4), (1,2)(4,5), (1,2)(3,4), \n  (1,2)(3,5), (1,2,3), (1,2,3,4,5), (1,2,3,5,4), (1,2,4,5,3), (1,2,4), \n  (1,2,4,3,5), (1,2,5,4,3), (1,2,5), (1,2,5,3,4), (1,3,2), (1,3,4,5,2), \n  (1,3,5,4,2), (1,3)(4,5), (1,3,4), (1,3,5), (1,3)(2,4), (1,3,2,4,5), \n  (1,3,5,2,4), (1,3)(2,5), (1,3,2,5,4), (1,3,4,2,5), (1,4,5,3,2), (1,4,2), \n  (1,4,3,5,2), (1,4,3), (1,4,5), (1,4)(3,5), (1,4,5,2,3), (1,4)(2,3), \n  (1,4,2,3,5), (1,4,2,5,3), (1,4,3,2,5), (1,4)(2,5), (1,5,4,3,2), (1,5,2), \n  (1,5,3,4,2), (1,5,3), (1,5,4), (1,5)(3,4), (1,5,4,2,3), (1,5)(2,3), \n  (1,5,2,3,4), (1,5,2,4,3), (1,5,3,2,4), (1,5)(2,4) ]\ngap&gt; Size( comms );\n60\ngap&gt; comms = Set( DerivedSubgroup( G ));\ntrue\ngap&gt; DerivedSubgroup( G ) = AlternatingGroup( 5 );\ntrue\nA computação em cima mostra que, no caso do grupo \\(S_5\\), o subgrupo derivado (ou seja, o subgrupo \\(A_5\\)) coincide com o conjunto de comutadores.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Comutadores em grupos</span>"
    ]
  },
  {
    "objectID": "commutators.html#tarefa-1",
    "href": "commutators.html#tarefa-1",
    "title": "10  Comutadores em grupos",
    "section": "10.3 Tarefa 1",
    "text": "10.3 Tarefa 1\n\nEscreva uma função nr_commutators( G ) que para um grupo G dado, computa o número de comutadores distintos de G. A sua função deve verificar:\ngap&gt; nr_comms( SymmetricGroup( 5 ));\n60\ngap&gt; nr_comms( AlternatingGroup( 5 ));\n60\ngap&gt; nr_comms( DihedralGroup( 20  ));\n5\ngap&gt; nr_comms( AlternatingGroup( 4  ));\n4\ngap&gt; nr_comms( PGL( 2, 7 ));\n168\ngap&gt; Size( DerivedSubgroup( SymmetricGroup( 5 )));\n60\ngap&gt; Size( DerivedSubgroup( AlternatingGroup( 5 )));\n60\ngap&gt; Size( DerivedSubgroup( DihedralGroup( 10 )));\n5\ngap&gt; Size( DerivedSubgroup( PGL( 2,7 )));\n168\n\n\nEscreva uma função encapsulando o código no exemplo anterior em uma função.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Comutadores em grupos</span>"
    ]
  },
  {
    "objectID": "commutators.html#tarefa-2",
    "href": "commutators.html#tarefa-2",
    "title": "10  Comutadores em grupos",
    "section": "10.4 Tarefa 2",
    "text": "10.4 Tarefa 2\n\nEscreva uma função commutator_set_is_subgroup( G ) para verificar se o conjunto de comutadores é igual ao subgrupo derivado de um grupo G. A função deve devolver true ou false. Note que é suficiente verificar se a cardinalidade do conjunto de comutadores é igual à cardinalidade do subgrupo derivado. A sua função deve seguir os seguintes exemplos.\ngap&gt; commutator_set_is_subgroup( SymmetricGroup( 5 ));\ntrue\ngap&gt; commutator_set_is_subgroup( AlternatingGroup( 5 ));\ntrue\ngap&gt; commutator_set_is_subgroup( DihedralGroup( 10 ));\ntrue\ngap&gt; commutator_set_is_subgroup( PGL( 2, 7 ));\ntrue",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Comutadores em grupos</span>"
    ]
  },
  {
    "objectID": "commutators.html#tarefa-3",
    "href": "commutators.html#tarefa-3",
    "title": "10  Comutadores em grupos",
    "section": "10.5 Tarefa 3",
    "text": "10.5 Tarefa 3\n\nUsando a função AllSmallGroups( Size, list ), ache o menor grupo G tal que o conjunto de comutadores de G não é o grupo derivado. Por exemplo, vamos verificar que entre os grupos de ordem 24 isso não ocorre.\ngap&gt; List( AllSmallGroups( Size, [24] ), G -&gt; commutator_set_is_subgroup( G ));\n[ true, true, true, true, true, true, true, true, true, true, true, true, \n  true, true, true ]",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Comutadores em grupos</span>"
    ]
  },
  {
    "objectID": "commutators.html#tarefa-4",
    "href": "commutators.html#tarefa-4",
    "title": "10  Comutadores em grupos",
    "section": "10.6 Tarefa 4",
    "text": "10.6 Tarefa 4\n\nSeja \\(G\\) o grupo encontrado na tarefa anterior.\n\nFaça a lista dos elementos do subgrupo derivado \\(G'\\) que não são comutadores.\nEscreva estes elementos como produto de comutadores de \\(G\\). Demonstre que todo elemento de \\(G'\\) pode ser escrito na forma \\([x_1,x_2][y_1,y_2]\\) com \\(x_i,y_i\\in G\\).",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Comutadores em grupos</span>"
    ]
  },
  {
    "objectID": "commutators.html#tarefa-5",
    "href": "commutators.html#tarefa-5",
    "title": "10  Comutadores em grupos",
    "section": "10.7 Tarefa 5",
    "text": "10.7 Tarefa 5\n\nPara um grupo \\(G\\) e \\(x\\in G\\), denote por \\(B_x(G)\\) o seguinte conjunto: \\[\nB_x(G)=\\{u^{-1}x^{-1}uv^{-1}xv\\mid u,v\\in G\\}.\n\\] \n\nEscreva uma função B_x( G, x ) que calcula \\(B_x(G)\\) para um grupo \\(G\\) e elemento \\(x\\in G\\).\nDecide quais dos seguintes grupos possui elemento \\(x\\) tal que \\(B_x(G)=G\\): \\(D_8\\), \\(Q_8\\), \\(A_4\\), \\(S_4\\), \\(A_5\\), \\(S_5\\).\n\n\n\nUse Cartesian para criar o produto cartesiano de duas listas (manual).",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Comutadores em grupos</span>"
    ]
  },
  {
    "objectID": "cubo.html",
    "href": "cubo.html",
    "title": "11  Grupos livres e o cubo mágico",
    "section": "",
    "text": "11.1 O cubo mágico",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Grupos livres e o cubo mágico</span>"
    ]
  },
  {
    "objectID": "cubo.html#o-cubo-mágico",
    "href": "cubo.html#o-cubo-mágico",
    "title": "11  Grupos livres e o cubo mágico",
    "section": "",
    "text": "O cubo mágico, como outros brincedos de lógica, pode ser analisado usando o sistema GAP. Neste projeto vamos analizar o grupo associado com o cubo mágico e vamos criar um algoritmo baseado na teoria dos grupos livres para a solução do cubo.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Grupos livres e o cubo mágico</span>"
    ]
  },
  {
    "objectID": "cubo.html#exploração-interativa",
    "href": "cubo.html#exploração-interativa",
    "title": "11  Grupos livres e o cubo mágico",
    "section": "11.2 Exploração interativa",
    "text": "11.2 Exploração interativa\n\nO cubo tem 48 peças cujas posições estão ilustradas no seguinte diagrama.\n                     +--------------+\n                     |              |\n                     |  1    2    3 |\n                     |              |\n                     |  4  CIMA   5 |\n                     |              |\n                     |  6    7    8 |\n                     |              |\n      +--------------+--------------+--------------+--------------+\n      |              |              |              |              |\n      |  9   10   11 | 17   18   19 | 25   26   27 | 33   34   35 |\n      |              |              |              |              |\n      | 12  ESQ   13 | 20 FRENTE 21 | 28 DIREIT 29 | 36  TRAS  37 |\n      |              |              |              |              |\n      | 14   15   16 | 22   23   24 | 30   31   32 | 38   39   40 |\n      |              |              |              |              |\n      +--------------+--------------+--------------+--------------+\n                     |              |\n                     | 41   42   43 |\n                     |              |\n                     | 44  BAIX  45 |\n                     |              |\n                     | 46   47   48 |\n                     |              |\n                     +--------------+\n\nTodo movimento pode ser visto como uma permutação dessas peças. Por exemplo girar o topo induz a permutação seguinte.\ngap&gt; c := (1,6,8,3)(2,4,7,5)(9,17,25,33)(10,18,26,34)(11,19,27,35);\nNós definimos similarmente as outras permutações que correspondem a girar os outros lados. O grupo de permutações que corresponde ao cubo é o subgrupo de \\(S_{48}\\) gerado por essas permutações.\ngap&gt; e := (1,40,41,17)(4,37,44,20)(6,35,46,22)(9,14,16,11)(10,12,15,13);\ngap&gt; f := (6,16,43,25)(7,13,42,28)(8,11,41,30)(17,22,24,19)(18,20,23,21);\ngap&gt; d := (3,19,43,38)(5,21,45,36)(8,24,48,33)(25,30,32,27)(26,28,31,29);\ngap&gt; t := (1,27,48,14)(2,29,47,12)(3,32,46,9)(33,38,40,35)(34,36,39,37);\ngap&gt; b := (14,38,30,22)(15,39,31,23)(16,40,32,24)(41,46,48,43)(42,44,47,45);\ngap&gt; G := Group( c, e, f, d, t, b );\n&lt;permutation group with 6 generators&gt;\nCalculemos a ordem de G. A ordem de G coincide com o número de configurações do cubo.\ngap&gt; Size( G );                     \n43252003274489856000\ngap&gt; Factors( last );              \n[ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, \n  2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 5, 7, 7, 11 ]\ngap&gt; Collected( last );\n[ [ 2, 27 ], [ 3, 14 ], [ 5, 3 ], [ 7, 2 ], [ 11, 1 ] ]\nVamos ver como transformar uma configuração a um elemento de \\(G\\). Considere por exemplo a seguinte configuração.\n                     +--------------+\n                     |              |\n                     |  16   4   46 |\n                     |              |\n                     |  13 CIMA  31 |\n                     |              |\n                     |  38   39   8 |\n                     |              |\n      +--------------+--------------+--------------+--------------+\n      |              |              |              |              |\n      |  22  20   32 | 48   47   19 | 25   45   14 | 40   10   41 |\n      |              |              |              |              |\n      | 29  ESQ   42 | 23 FRENTE  5 | 26 DIREIT 12 | 37   TRAS 36 |\n      |              |              |              |              |\n      | 27   15   43 | 24   21   11 | 6     7    9 | 35   34   33 |\n      |              |              |              |              |\n      +--------------+--------------+--------------+--------------+\n                     |              |\n                     | 30   28   17 |\n                     |              |\n                     | 44  BAIX  18 |\n                     |              |\n                     | 3     2   1  |\n                     |              |\n                     +--------------+\nNote que, a peça 16 aparece no lugar de 1, 4 no lugar de 2, 46 no lugar de 3, etc. Nós precisamos construir a permutação que leva \\[\n1\\mapsto 16,\\quad 2\\mapsto 4,\\quad 3\\mapsto 46,\\ldots\n\\] Esta permutação pode ser construída usando as seguintes instruções.\ngap&gt; s := [16,4,46,13,31,38,39,8,22,20,32,29,42,27,15,43,48,47,19,23,5,24,21,11,25,45,14,26,12,6,7,9,40,10,41,37,36,35,34,33,30,28,17,44,18,3,2,1];\ngap&gt; x := PermList( s );            \n(1,16,43,17,48)(2,4,13,42,28,26,45,18,47)(3,46)(5,31,7,39,34,10,20,23,21)(6,\n38,35,41,30)(9,22,24,11,32)(12,29)(14,27)(33,40)(36,37)\ngap&gt; x in G;\ntrue",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Grupos livres e o cubo mágico</span>"
    ]
  },
  {
    "objectID": "cubo.html#tarefa-1",
    "href": "cubo.html#tarefa-1",
    "title": "11  Grupos livres e o cubo mágico",
    "section": "11.3 Tarefa 1",
    "text": "11.3 Tarefa 1\n\nSeja \\(X\\) um grupo. Lembre que uma série \\[\nX_0&gt;X_1&gt;X_2&gt;\\cdots&gt;X_m=1\n\\] de subgrupos é dita série de composição se \\(X_{i+1}\\) é um subgrupo normal em \\(X_i\\) e \\(X_i/X_{i+1}\\) é um grupo simples para todo \\(i\\) (ou seja, \\(X_i/X_{i+1}\\) não possui subgrupo normal próprio e não trivial). A série de composição em um grupo, pode não ser única, mas sabemos pelo Teorema de Jordan-Holder que o comprimento da séries e os tipos de isomorfismo dos fatores (os fatores de composição) são unicamente determinados por \\(X\\). Estes fatores podem ser vistos como os blocos elementares do grupo similarmente aos fatores primos dos números naturais.\nNo seguinte exemplo simples vamos determinar os fatores de composição do grupo dihedral \\(D_{10}\\) (as simetrias do pentágono).\ngap&gt; G := DihedralGroup( 10 );\n&lt;pc group of size 10 with 2 generators&gt;\ngap&gt; C := CompositionSeries( G );\n[ Group([ f1, f2 ]), Group([ f2 ]), Group([  ]) ]\ngap&gt; List( [1..2], i-&gt;C[i]/C[i+1] );\n[ Group([ f1, &lt;identity&gt; of ... ]), Group([ f2 ]) ]\ngap&gt; List( [1..2], i-&gt;StructureDescription(C[i]/C[i+1]) );\n[ \"C2\", \"C5\" ]\nTemos que a série de composição de \\(D_{10}\\) tem comprimento \\(2\\) e os dois fatores são cíclicos de ordem \\(2\\) e \\(5\\).\nAgora responda às seguintes perguntas sobre o grupo \\(G\\) do cubo mágico.\n\nQual é o comprimento da série de composição do grupo \\(G\\)?\nQuantos fatores são abelianos e quantos são não abelianos.\nOs fatores abelianos, sendo grupos simples, são cíclicos; determine as suas ordens.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Grupos livres e o cubo mágico</span>"
    ]
  },
  {
    "objectID": "cubo.html#tarefa-2",
    "href": "cubo.html#tarefa-2",
    "title": "11  Grupos livres e o cubo mágico",
    "section": "11.4 Tarefa 2",
    "text": "11.4 Tarefa 2\n\nVamos estudar a estrutura permutacional do grupo \\(G\\).\n\nDetermine as órbitas de \\(G\\) agindo no conjunto das 48 peças.\nDê uma intepretação destas órbitas.\nLembre que um subconjunto \\(\\Delta\\) das peças chama-se bloco se \\(\\Delta g=\\Delta\\) ou \\(\\Delta g\\cap \\Delta=\\emptyset\\). Determine os blocos contidos nas órbitas de \\(G\\).\nDê interpretação destes blocos.\n\n\n\n\nUse as funções Orbits (manual) e Blocks (manual).",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Grupos livres e o cubo mágico</span>"
    ]
  },
  {
    "objectID": "cubo.html#tarefa-3",
    "href": "cubo.html#tarefa-3",
    "title": "11  Grupos livres e o cubo mágico",
    "section": "11.5 Tarefa 3",
    "text": "11.5 Tarefa 3\n\nFinalmente nós vamos resolver o cubo usando um homomorfismo do grupo livre em \\(G\\). Seja \\(\\mathcal F\\) o grupo livre gerado pelos geradores \\(C\\), \\(E\\), \\(F\\), \\(D\\), \\(T\\), \\(B\\). Note que \\(\\mathcal F\\) é gerado por \\(6\\) elementos e cada gerador de \\(\\mathcal F\\) corresponde a um gerador de \\(G\\). A propriedade universal do grupo livre implica que o mapa \\[\nC\\mapsto c,\\ E\\mapsto e, F\\mapsto f,\\ D\\mapsto d,\\ T\\mapsto t,\\ B\\mapsto b\n\\] pode ser extendido a um único homomorfismo \\(f:\\mathcal F\\to G\\). Se \\(g\\in G\\) e \\(w\\) é uma pré-imagem de \\(g\\), então \\(w\\) mostra como escrever \\(g\\) em uma palavra nos geradores de \\(G\\). Ou seja, \\(w\\) monstra como obter a configuração que corresponde ao elemento \\(g\\) como uma sequência dos \\(6\\) movimentos básicos.\nIlustramos esta ideia com um exemplo simpes usando o grupo \\(D_{10}\\).\ngap&gt; a := (1,2,3,4,5); b := (2,5)(3,4);\n(1,2,3,4,5)\n(2,5)(3,4)\ngap&gt; G := Group( a, b );\nGroup([ (1,2,3,4,5), (2,5)(3,4) ])\ngap&gt; Fr := FreeGroup( \"A\", \"B\" );\n&lt;free group on the generators [ A, B ]&gt;\ngap&gt; hom := GroupHomomorphismByImages( Fr, G, GeneratorsOfGroup( Fr ), GeneratorsOfGroup( G ));\n[ A, B ] -&gt; [ (1,2,3,4,5), (2,5)(3,4) ]\ngap&gt; x := Random( G );\n(1,4)(2,3)\ngap&gt; PreImagesRepresentative( hom, x );\nA^-1*B^-1*A^-3\nO resultado diz que a permutação \\(x=(1,4)(2,3)\\) pode ser obtida como a composição \\(a^{-1}b^{-1}a^{-3}\\). De fato\ngap&gt; a^-1*b^-1*a^-3 = x;\ntrue\n\nConstrua o grupo \\(F\\) em cima em GAP usando FreeGroup (manual).\nConstrua o homomorfismo \\(f\\) em cima usando GroupHomomorphismByImages (manual).\nConsidere a configuração do cubo na Tarefa 1. Construa a sequência dos movimentos que resulta nesta configuração.\nConsidere uma configuração aleatória do cubo por escolhendo um elemento aleatório de \\(G\\) (usando Random( G )). Construa a sequência dos movimentos que resulta nesta configuração aleatória.\nUsando um dos cubos disponibilizados por Igor e Csaba, obtenha a configuração da Tarefa 1.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Grupos livres e o cubo mágico</span>"
    ]
  },
  {
    "objectID": "cubo.html#tarefa-4",
    "href": "cubo.html#tarefa-4",
    "title": "11  Grupos livres e o cubo mágico",
    "section": "11.6 Tarefa 4",
    "text": "11.6 Tarefa 4\n\n\nVerifique que \\(G\\) pode ser gerado por 2 elementos. Dica: Pegue usando Random( G ) dois elementos aliatórios em \\(G\\) e verifique se o grupo gerado por eles coincide com \\(G\\).\nAche um subconjunto mínimo \\(S\\) do conjunto \\(\\{c,e,f,d,t,b\\}\\) de geradores tal que \\(\\left&lt;S\\right&gt;=G\\).\nConstrua a configuração da Tarefa 1 usando apenas os movimentos do conjunto \\(S\\) no ponto anterior.\nSeja \\(C\\) o conjunto de 8 peças de canto (as peças que possuem 3 cores). O grupo \\(G\\) age sobre o conjunto \\(C\\). Mostre que \\(G\\) induz \\(S_{8}\\) sobre o conjunto dessas peças. Similarmente, seja \\(L\\) o conjunto das 12 peças laterias (as peças que possuem 2 cores). Mostre que \\(G\\) induz \\(S_{12}\\) sobre \\(L\\). (Isso explica os grupos \\(A_8\\) e \\(A_{12}\\) entre os fatores de composição de \\(G\\)). Use Action( G, conj, act )(manual).",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Grupos livres e o cubo mágico</span>"
    ]
  },
  {
    "objectID": "centralizers.html",
    "href": "centralizers.html",
    "title": "12  Uma questão sobre centralizadores",
    "section": "",
    "text": "12.1 Os fundamentos teóricos",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Uma questão sobre centralizadores</span>"
    ]
  },
  {
    "objectID": "centralizers.html#os-fundamentos-teóricos",
    "href": "centralizers.html#os-fundamentos-teóricos",
    "title": "12  Uma questão sobre centralizadores",
    "section": "",
    "text": "Recordamos que o centralizador de um elemento \\(x\\) em um grupo \\(G\\) é definido por \\[\nC_{G}(x) = \\{g \\in G | \\ gx=xg \\}.\n\\]\nDenote por \\(\\mbox{Cent}(G)\\) o conjunto de todos os centralizadores de elementos de \\(G\\).\nPor exemplo, se \\(G=S_3\\), então temos os seguintes centralizadores dos seus elementos:\n\n\n\n\n\n\n\n\n\n\n\n\nelemento\n1\n\\((1,2)\\)\n\\((1,3)\\)\n\\((2,3)\\)\n\\((1,2,3)\\)\n\\((1,3,2)\\)\n\n\n\n\ncentralizador\n\\(S_3\\)\n\\(\\left&lt;(1,2)\\right&gt;\\)\n\\(\\left&lt;(1,3)\\right&gt;\\)\n\\(\\left&lt;(2,3)\\right&gt;\\)\n\\(\\left&lt;(1,2,3)\\right&gt;\\)\n\\(\\left&lt;(1,2,3)\\right&gt;\\)\n\n\n\nNote que o subgrupo \\(\\left&lt;(1,2,3)\\right&gt;\\) aparece duas vezes, então \\[\n\\mbox{Cent}(S_3)=\\{S_3,\\left&lt;(1,2)\\right&gt;, \\left&lt;(1,3)\\right&gt;, \\left&lt;(2,3)\\right&gt;, \\left&lt;(1,2,3)\\right&gt;\\}\n\\] e \\[\n|\\mbox{cent}(S_3)|=5.\n\\]\nO estudo de \\(\\mbox{Cent}(G)\\) tem chamado a atenção de muitos pesquisadores. As duas principais motivações para se estudar \\(\\mbox{Cent}(G)|\\) é responder essencialmente duas questões:\n\nDado um grupo \\(G\\), o que se pode dizer sobre \\(|\\mbox{Cent}(G)|\\)?\nSe é conhecido o valor de \\(|\\mbox{Cent}(G)|\\), o que se pode dizer a respeito do grupo \\(G\\)?\n\nNeste projeto, queremos usar o GAP para resolver algumas questões para grupos simples finitos.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Uma questão sobre centralizadores</span>"
    ]
  },
  {
    "objectID": "centralizers.html#tarefa-1",
    "href": "centralizers.html#tarefa-1",
    "title": "12  Uma questão sobre centralizadores",
    "section": "12.2 Tarefa 1",
    "text": "12.2 Tarefa 1\n\nVamos determinar o centralizador de um elemento em um grupo. Considere o seguinte exemplo.\ngap&gt; G := AlternatingGroup( 5 );\nAlt( [ 1 .. 5 ] )\ngap&gt; x := (1,2,3);\n(1,2,3)\ngap&gt; Cx := Centralizer( G, x );\nGroup([ (1,2,3) ])\ngap&gt; Size( Cx );\n3\nSeguindo o exemplo em cima, determine os seguintes centralizadores \\(C_G(x)\\).\n\n\\(G=S_6\\), \\(x=(1,2,3)(4,5,6)\\).\n\\(G=D_8\\) (diedral de ordem 8) e \\(x\\) é uma rotação por \\(90\\) graus.\n\\(G=\\mbox{GL}(2,5)\\) e \\(x\\) é a matriz diagonal com \\((2,3)\\) na diagonal principal.\n\n\n\nConsulte Seção 4.1 para ver como definir o grupo GL e o grupo diedral.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Uma questão sobre centralizadores</span>"
    ]
  },
  {
    "objectID": "centralizers.html#exploração-interativa",
    "href": "centralizers.html#exploração-interativa",
    "title": "12  Uma questão sobre centralizadores",
    "section": "12.3 Exploração interativa",
    "text": "12.3 Exploração interativa\n\nPara investigar o problema em cima, nós precisamos determinar o conjunto dos centralizadores em um grupo dado. Vamos fazer esta computação com o grupo \\(S_5\\).\ngap&gt; G := SymmetricGroup( 3 );\nSym( [ 1 .. 3 ] )\ngap&gt; cent := List( G, x-&gt;Centralizer( G, x ));\n[ Group([ (1,3), (2,3) ]), Group([ (2,3) ]), Group([ (1,3) ]), Group([ (1,3,2) ]), \n  Group([ (1,2,3) ]), Group([ (1,2) ]) ]\ngap&gt; cent[5] = cent[6];\nfalse\ngap&gt; cent[4] = cent[5];\ntrue\ngap&gt; cent_set := Set( G, x-&gt;Centralizer( G, x ));\n[ Group([ (2,3) ]), Group([ (1,3), (2,3) ]), Group([ (1,2) ]), Group([ (1,3,2) ]), \n  Group([ (1,3) ]) ]\ngap&gt; Size( cent );\n6\ngap&gt; Size( cent_set );\n5\nOu seja, \\(S_3\\) possui 5 centralizadores (como foi visto em cima). Note que usamos a função Set que vai devolver um conjunto; ou seja, todo elemento do output será aparece apenas uma vez.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Uma questão sobre centralizadores</span>"
    ]
  },
  {
    "objectID": "centralizers.html#tarefa-2",
    "href": "centralizers.html#tarefa-2",
    "title": "12  Uma questão sobre centralizadores",
    "section": "12.4 Tarefa 2",
    "text": "12.4 Tarefa 2\n\nEscreva uma função Cent(G) para computar o conjunto de todos os centralizadores de elementos de um grupo \\(G\\) dado. Use a função Centralizer(G,x) (manual).\nSua função deve verificar:\ngap&gt; Cent( SymmetricGroup( 3 ));                  \n[ Group([ (2,3) ]), Group([ (1,3), (2,3) ]), Group([ (1,2) ]), \n  Group([ (1,3,2) ]), Group([ (1,3) ]) ]\ngap&gt; Cent( AlternatingGroup( 4 ));\n[ Group([ (2,4,3) ]), Group([ (1,2,4), (1,3,4) ]), \n  Group([ (1,2)(3,4), (1,4)(2,3) ]), Group([ (1,3,2) ]), Group([ (1,4,2) ]), \n  Group([ (1,4,3) ]) ]\ngap&gt; Cent( SmallGroup( 16,7 ));   \n[ Group([ f1, f4 ]), Group([ f2, f4 ]), \n  &lt;pc group of size 16 with 4 generators&gt;, Group([ f1*f2, f3, f4 ]), \n  Group([ f1*f3, f4 ]), Group([ f2*f3, f4 ]) ]\ngap&gt; Size(Cent(AlternatingGroup(6)));\n137\ngap&gt; Size(Cent(AlternatingGroup(5)));\n807\ngap&gt; Size(Cent(PSL(2,7)));\n79\ngap&gt; Size(Cent(PSL(3,3)));\n1185\ngap&gt; Size(Cent(DihedralGroup(8)));\n4\ngap&gt; Size(SmallGroup(16,7));\n6\ngap&gt; Size(Cent(MathieuGroup(11)));\n2081",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Uma questão sobre centralizadores</span>"
    ]
  },
  {
    "objectID": "centralizers.html#tarefa-3",
    "href": "centralizers.html#tarefa-3",
    "title": "12  Uma questão sobre centralizadores",
    "section": "12.5 Tarefa 3",
    "text": "12.5 Tarefa 3\n\nAgora você precisa responder a seguinte questão\n\n[Questão de Ashrafi e Taeri] Sejam \\(G\\) e \\(H\\) grupos simples não abelianos. É verdade que se \\(|\\mbox{Cent}(G)| = |\\mbox{Cent}(H)|\\), então \\(G\\) é isomorfo a \\(H\\)?\n\n\n\nIs grupos simples não abelianos podem ser acessos usando a função AllSmallNonabelianSimpleGroups( list ) onde list é uma lista de números naturais. A função devolve a lista dos grupos simples abelianos cuja ordem está na lista list. Por exemplo:\ngap&gt; AllSmallNonabelianSimpleGroups( [1..200] );\n[ A5, PSL(2,7) ]\nOu seja, existem apenas \\(2\\) grupos simples com ordem entre \\(1\\) e \\(200\\); nomeadamente \\(A_5\\) e \\(\\mbox{PSL}(2,7)\\). Use a função AllSmallNonabelianSimpleGroups para gerar grupos simples e compare os seus números de centralizadores.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Uma questão sobre centralizadores</span>"
    ]
  },
  {
    "objectID": "centralizers.html#tarefa-4",
    "href": "centralizers.html#tarefa-4",
    "title": "12  Uma questão sobre centralizadores",
    "section": "12.6 Tarefa 4",
    "text": "12.6 Tarefa 4\n\nE se restringirmos a função para sabermos a quantidade dos centralizadores abelianos ou dos centralizadores não abelianos de um grupo? Será que se dois grupos simples não abelianos tiverem a mesma quantidade de centralizadores abelianos (ou não abelianos) de elementos, esses grupos são necessariamente isomorfos?\n\nEscreva uma nova versão da função Cent( G ) que aceita, além do grupo G, um argumento opcional (veja Seção 5.5) que pode ser true ou false. Se o valor do argumento opcional for true, a função devolve o conjunto dos centralizadores abelianos; se o valor for false, devolve o conjunto dos centralizadores não abelianos.\n\ngap&gt; cent( AlternatingGroup( 4 ));\n[ Group([ (2,4,3) ]), Group([ (1,2,4), (1,3,4) ]), \n  Group([ (1,2)(3,4), (1,4)(2,3) ]), Group([ (1,3,2) ]), Group([ (1,4,2) ]), \n  Group([ (1,4,3) ]) ]\ngap&gt; cent( AlternatingGroup( 4 ), true );\n[ Group([ (2,4,3) ]), Group([ (1,2)(3,4), (1,4)(2,3) ]), Group([ (1,3,2) ]), \n  Group([ (1,4,2) ]), Group([ (1,4,3) ]) ]\ngap&gt; cent( AlternatingGroup( 4 ), false );\n[ Group([ (1,2,4), (1,3,4) ]) ]\n\nAche dois grupos simples não abelianos não isomorfos que têm o mesmo número de centralizadores abelianos ou não abelianos.\n\n\n\n\nFunções com argumentos opcionais foram tratadas na Seção 5.5.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Uma questão sobre centralizadores</span>"
    ]
  },
  {
    "objectID": "centralizers.html#tarefa-5",
    "href": "centralizers.html#tarefa-5",
    "title": "12  Uma questão sobre centralizadores",
    "section": "12.7 Tarefa 5",
    "text": "12.7 Tarefa 5\n\nNesta próxima tarefa, vamos usar o conceito de grupos isoclínicos (desenvolvido por P. Hall em seu artigo influenciador de 1940). Dois grupos \\(G\\) e \\(H\\) são ditos isoclínicos se existem dois isomorfismos \\[\n\\phi: \\frac{G}{Z(G)} \\rightarrow \\frac{H}{Z(H)}\\quad \\mbox{e} \\quad\\psi: G' \\rightarrow H'\n\\] tais que se \\[\n\\phi(g_1Z(G))=h_1Z(H)\\quad\\mbox{e} \\quad\\phi(g_2Z(G))=h_2Z(H)\n\\] para \\(g_1,g_2 \\in G\\) e \\(h_1,h_2 \\in H\\), então \\(\\psi([g_1,g_2])= [h_1,h_2]\\). É possível mostrar que isoclinismo é uma relação de equivalência e que grupos abelianos são isoclínicos ao grupo trivial.\nPor exemplo, pode se verificar que o grupo dihedral \\(D_8\\) e o grupo de quaternions \\(Q_8\\) são isoclínicos, mas os grupos \\(D_8\\) e \\(D_{10}\\) não são.\ngap&gt; LoadPackage( \"xmod\" );\ntrue\ngap&gt; f := Isoclinism( DihedralGroup(8), QuaternionGroup(8));\n[ [ f1, f2 ] -&gt; [ f2, f1*f2 ], [ f3 ] -&gt; [ y2 ] ]\ngap&gt; Isoclinism( DihedralGroup( 8 ), DihedralGroup( 10 ));\nfail\nM. Zarrin usou o isoclinismo para estender os resultados sobre centralizados de elementos para grupos infinitos. Em particular, ele provou que se \\(G\\) e \\(H\\) são isoclínicos, então \\(|\\mbox{Cent}(G)| = |\\mbox{Cent}(H)|\\). Nesta tarefa vamos verificar a seguinte questão de Khoramshahi and M. Zarrin.\n\nAche dois grupos \\(G\\) e \\(H\\) tal que \\(|\\mbox{Cent}(G)|=|\\mbox{Cent}(H)|\\), \\(|H|=|G|\\), \\(|G'|=|H'|\\), mas \\(G\\) e \\(H\\) não são isoclínicos.\nKhoromshahi e Zarrin mostrou que se \\(G\\) e \\(H\\) são como no item anterior, então \\(|\\mbox{Cent}(G)|\\leq 5\\). Ache exemplos com \\(|\\mbox{Cent}(G)|=6\\) para verificar que esta quota superior não pode ser melhorada.\n\n\n\n\nPara gerar os candidatos entre os possíveis grupos, use a função AllSmallGroups. Por exemplo, pode gerar os grupos de ordem entre \\(1\\) e \\(20\\) com 6 centralizadores com o seguinte código:\ngap&gt; AllSmallGroups( Size, [1..20], x-&gt;Size( cent( x )) = 6 );\n[ &lt;pc group of size 12 with 3 generators&gt;, \n  &lt;pc group of size 16 with 4 generators&gt;, \n  &lt;pc group of size 16 with 4 generators&gt;, \n  &lt;pc group of size 16 with 4 generators&gt; ]",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Uma questão sobre centralizadores</span>"
    ]
  },
  {
    "objectID": "semidirect.html",
    "href": "semidirect.html",
    "title": "13  Produto semidireto",
    "section": "",
    "text": "13.1 O produto semidireto de grupos",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Produto semidireto</span>"
    ]
  },
  {
    "objectID": "semidirect.html#o-produto-semidireto-de-grupos",
    "href": "semidirect.html#o-produto-semidireto-de-grupos",
    "title": "13  Produto semidireto",
    "section": "",
    "text": "Dados dois grupos \\(N\\) e \\(H\\) e um homomorfismo \\(\\alpha:H\\to\\mbox{Aut}(H)\\), construimos o produto semidireto \\(G=N\\rtimes H\\) na segiunte forma. O conjunto de \\(G\\) é o produto cartesiano \\(N\\times H\\) e a multiplicação está definida pela seguinte regra: \\[\n(n_1,h_1)(n_2,h_2)=(n_1\\cdot \\alpha(h_1)(n_2),h_1h_2).\n\\] É um exercício fácil mostrar que esta regra define um grupo. Neste projeto vamos ver como construir produto semidireto em GAP e depois vamos usar esta construção para construir os grupos de ordem \\(12\\)",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Produto semidireto</span>"
    ]
  },
  {
    "objectID": "semidirect.html#exploração-interativa",
    "href": "semidirect.html#exploração-interativa",
    "title": "13  Produto semidireto",
    "section": "13.2 Exploração interativa",
    "text": "13.2 Exploração interativa\n\nUsando a função AutomorphismGroup(G), vamos construir alguns automorfimos.\ngap&gt; AutomorphismGroup(SmallGroup(4, 2));\n&lt;group with 4 generators&gt;\ngap&gt; StructureDescrition(last);\n\"S3\"\ngap&gt; AutomorphismGroup(DirectProduct(CyclicGroup(2), CyclicGroup(2)));\n&lt;group with 4 generators&gt;\ngap&gt;  StructureDescription(last);\n\"S3\"\ngap&gt;  AutomorphismGroup(CyclicGroup(3)); \n&lt;group with 1 generator&gt;\ngap&gt; StructureDescription( last );\n\"C2\"",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Produto semidireto</span>"
    ]
  },
  {
    "objectID": "semidirect.html#tarefa-1",
    "href": "semidirect.html#tarefa-1",
    "title": "13  Produto semidireto",
    "section": "13.3 Tarefa 1",
    "text": "13.3 Tarefa 1\n\nAgora vamos construir alguns homomorfismos de um grupo \\(H\\) para o grupo de automorfismos de \\(N\\), nos casos em que tais grupos são: \\(C_2 \\times C_2\\) ou \\(C_4\\) ou \\(C_3\\). Usaremos a função GroupHomomorphismByImages( H, AutomorphismGroup(N), gens, imgs ), onde gens é uma lista de geradores de H de mesmo tamanho da lista de respectivas imagens imgs em AutomorphismGroup(N).\nPrimeiro, vamos fazer um exemplo e construir um homomorfismo do grupo grupo simétrico \\(S_4=\\left&lt;(1,2), (1,2,3,4)\\right&gt;\\) para o grupo \\(\\mbox{Aut}(S_3) \\cong S_3 =\\left&lt;(1,2), (1,2,3)\\right&gt;\\).\ngap&gt; s4 := SymmetricGroup(4);\nSym( [ 1 .. 4 ] )\ngap&gt;  gens:=GeneratorsOfGroup(s4);\n[ (1,2,3,4), (1,2) ]\ngap&gt;  s3:=SymmetricGroup(3);\nSym( [ 1 .. 3 ] )\ngap&gt;  imgs:=[(1,2),(2,3)];\n[ (1,2), (2,3) ]\ngap&gt;  f := GroupHomomorphismByImages(s4, s3, gens, imgs);\n[ (1,2,3,4), (1,2) ] -&gt; [ (1,2), (2,3) ]\ngap&gt;  Image(f,(1,2,3,4));\n(1,2)\ngap&gt;  Image(f, (1,3)(2,4));\n()\ngap&gt;  Image(f, (1,2,3,4)*(1,2));\n(1,3,2)\n\nAgora, construa um homomorfismo \\(f\\) de \\(h:=C_4\\) para \\(n:=Aut(C_3) \\cong C_2\\). Verifique qual é imagem de \\(a^3\\) por \\(f\\), onde \\(\\left&lt;a\\right&gt;=C_4\\).\nFaça o mesmo para \\(h:=C_2 \\times C_2\\) para \\(n:=Aut(C_3) \\cong C_2\\). Use a função DirectProduct e também GeneratorsOfGroup.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Produto semidireto</span>"
    ]
  },
  {
    "objectID": "semidirect.html#tarefa-2",
    "href": "semidirect.html#tarefa-2",
    "title": "13  Produto semidireto",
    "section": "13.4 Tarefa 2",
    "text": "13.4 Tarefa 2\n\nAgora vamos usar a função SemidirectProduct(H, a, N), onde \\(a\\) é um homomorfismo de \\(H\\) em \\(\\mbox{Aut}(N)\\), já construído em tarefa anterior. Vamos obter os produtos semidiretos com \\(H=C_4\\) e \\(N=C_3\\). E como tarefa, faça o mesmo com \\(H=C_2 \\times C_2\\).\ngap&gt; h:=CyclicGroup(4);\n&lt;pc group of size 4 with 2 generators&gt;\ngap&gt;  n:=CyclicGroup(3) ;\n&lt;pc group of size 3 with 1 generator&gt;\ngap&gt;  aut:=AutomorphismGroup(n);\n&lt;group with 1 generator&gt;\ngap&gt;  alpha:=GroupHomomorphismByImages(h, aut, [GeneratorsOfGroup(h)[1]], [GeneratorsOfGroup(aut)[1]]); \n[ f1 ] -&gt; [ [ f1 ] -&gt; [ f1^2 ] ]\ngap&gt;  g:=SemidirectProduct(h,alpha,n);\n&lt;pc group of size 12 with 3 generators&gt;\ngap&gt;  StructureDescription(g);\n\"C3 : C4\"\ngap&gt;  alpha:=GroupHomomorphismByImages(h, aut, [GeneratorsOfGroup(h)[1]], [GeneratorsOfGroup(aut)[1]^2]);\n[ f1 ] -&gt; [ Pcgs([ f1 ]) -&gt; [ f1 ] ]\ngap&gt;  g:=SemidirectProduct(h,alpha,n);\n&lt;pc group of size 12 with 3 generators&gt;\ngap&gt;  StructureDescription(g);\n\"C12\"",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Produto semidireto</span>"
    ]
  },
  {
    "objectID": "semidirect.html#tarefa-3",
    "href": "semidirect.html#tarefa-3",
    "title": "13  Produto semidireto",
    "section": "13.5 Tarefa 3",
    "text": "13.5 Tarefa 3\n\nUm modo alternativo de se obter os homomorfismos de \\(H\\) para \\(\\mbox{Aut}(N)\\) é usar a função AllHomomorphisms(H, AutomorphismGroup(N)). Vamos obter os homomorfismos de \\(H\\) para \\(\\mbox{Aut}(N)\\) usando tal função.\ngap&gt; h:=CyclicGroup(4);\n&lt;pc group of size 4 with 2 generators&gt;\ngap&gt;  n:=CyclicGroup(3);\n&lt;pc group of size 3 with 1 generator&gt;\ngap&gt;  aut:=AutomorphismGroup(n);\n&lt;group with 1 generator&gt;\ngap&gt;  a:=AllHomomorphisms(h, aut);\n[ [ f1 ] -&gt; [ IdentityMapping( &lt;pc group of size 3 with 1 generator&gt; ) ], \n  [ f1 ] -&gt; [ [ f1 ] -&gt; [ f1^2 ] ] ]\ngap&gt;  List(a, f-&gt; StructureDescription(SemidirectProduct(h, f, n)));\n[ \"C12\", \"C3 : C4\" ]\n\nUsando AllHomomorphism como acima, obtenha todos os produtos semidiretos de \\(H=C_3\\) para \\(N=C_4\\), de \\(H=C_2 \\times C_2\\) para \\(N=C_3\\) e também de \\(H=C_3\\) para \\(C_2 \\times C_2\\). Verifique nas suas respostas que os únicos grupos obtidos do produto semidireto \\(H \\rtimes N\\) são os seguintes:\nPortanto, existem exatamente \\(5\\) grupos de ordem \\(12\\), a menos de isomorfismos. Podemos obtê-los via produto semidireto \\(H \\rtimes N\\), onde os grupos \\(H\\) e \\(N\\) correspondem a um grupo de ordem \\(4\\) e de ordem \\(3\\), respectivamente e vice-versa.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Produto semidireto</span>"
    ]
  },
  {
    "objectID": "semidirect.html#tarefa-4",
    "href": "semidirect.html#tarefa-4",
    "title": "13  Produto semidireto",
    "section": "13.6 Tarefa 4",
    "text": "13.6 Tarefa 4\n\nEscreva uma função all_semidirect_products( N, H ) que devolve todos os produtos semidiretos \\(N\\rtimes H\\).",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Produto semidireto</span>"
    ]
  },
  {
    "objectID": "genord.html",
    "href": "genord.html",
    "title": "14  Carateres de um grupo e a ordem generalizada",
    "section": "",
    "text": "14.1 A ordem generalizada",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Carateres de um grupo e a ordem generalizada</span>"
    ]
  },
  {
    "objectID": "genord.html#a-ordem-generalizada",
    "href": "genord.html#a-ordem-generalizada",
    "title": "14  Carateres de um grupo e a ordem generalizada",
    "section": "",
    "text": "Seja \\(G\\) um grupo e \\(x\\in G\\). A ordem generalizada \\([x]\\) de \\(x\\) é o menor número natural \\(k\\) tal que a identidade \\(1\\) de \\(G\\) pode ser escrito como um produto de \\(k\\) conjugados de \\(x\\). Ou seja, \\([x]\\) é o menor natural \\(k\\) tal que \\[\nx^{g_1}\\cdots x^{g_k}=1\n\\] com algum \\(g_1,\\ldots,g_k\\in G\\).\n\nTeorema 14.1 Seja \\(G\\) um grupo finito, seja \\(g\\in G\\) e sejam \\(\\chi_1,\\ldots,\\chi_m\\) os carateres irredutíveis de \\(G\\). Defina, para \\(k\\geq 1\\), \\[\n\\alpha_{g,k}=\\frac {|G|^{k-1}}{|C_G(g)|^k}\\sum_{i=1}^m\\frac{\\chi_i(g)^k}{\\chi_i(1)^{k-2}}.\n\\tag{14.1}\\] Então \\(\\alpha_{g,k}\\) é um número natural e ele é igual ao número de maneiras de escrever a identidade \\(1\\) de \\(G\\) como produto de conjugados de \\(g\\). Em particular, \\[\n[g]=\\min\\{k\\geq 1\\mid \\alpha_{g,k}\\geq 1\\}.\n\\]",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Carateres de um grupo e a ordem generalizada</span>"
    ]
  },
  {
    "objectID": "genord.html#carateres-em-gap",
    "href": "genord.html#carateres-em-gap",
    "title": "14  Carateres de um grupo e a ordem generalizada",
    "section": "14.2 Carateres em GAP",
    "text": "14.2 Carateres em GAP\n\nVamos ver primeiro como trabalhar com carateres em GAP. Seja \\(G\\) um grupo finito e seja \\(\\varrho:G\\to \\operatorname{GL}(n,\\mathbb C)\\) um homomorfismo. O homomorfismo \\(\\varrho\\) chama-se também uma representação linear de \\(G\\). O carater associado com \\(\\varrho\\) é \\[\n\\chi:G\\to\\mathbb C,\\quad \\chi(g)=\\mbox{trace}(\\varrho(g)).\n\\] Note que \\(\\mbox{trace}\\) significa o traço da matriz \\(\\varrho(g)\\); ou seja, a soma dos elementos na diagonal principal. É bem conhecido que o caracter carrega muita informação sobre \\(\\varrho\\).\nEm GAP, carateres podem ser calculados na seguinte maneira. Note que estamos interessados principalmente nos carateres que correspondem às representações irredutíveis.\ngap&gt; G := SmallGroup( 24, 10 );\n&lt;pc group of size 24 with 4 generators&gt;\ngap&gt; t := CharacterTable( G );\nCharacterTable( &lt;pc group of size 24 with 4 generators&gt; )\ngap&gt; irr := Irr( t );\n[ Character( CharacterTable( &lt;pc group of size 24 with 4 generators&gt; ),\n  [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ), \n  Character( CharacterTable( &lt;pc group of size 24 with 4 generators&gt; ),\n  [ 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1 ] ), \n...etc...\ngap&gt; irr[3];\nCharacter( CharacterTable( &lt;pc group of size 24 with 4 generators&gt; ),\n [ 1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, -1 ] )\n\n\nVamos calcular a ordem generalizada de um elemento do grupo dihedral \\(D_8\\), usando a equação Equação 14.1.\ngap&gt; D8 := DihedralGroup( 8 );\n&lt;pc group of size 8 with 3 generators&gt;\ngap&gt; t := CharacterTable( D8 );\nCharacterTable( &lt;pc group of size 8 with 3 generators&gt; )\ngap&gt; OrdersClassRepresentatives( t );\n[ 1, 2, 4, 2, 2 ]\ngap&gt; irr := Irr( t );\n[ Character( CharacterTable( &lt;pc group of size 8 with 3 generators&gt; ),\n  [ 1, 1, 1, 1, 1 ] ), Character( CharacterTable( &lt;pc group of size 8 with \n    3 generators&gt; ), [ 1, -1, 1, 1, -1 ] ), \n  Character( CharacterTable( &lt;pc group of size 8 with 3 generators&gt; ),\n  [ 1, 1, -1, 1, -1 ] ), Character( CharacterTable( &lt;pc group of size 8 with \n    3 generators&gt; ), [ 1, -1, -1, 1, 1 ] ), \n  Character( CharacterTable( &lt;pc group of size 8 with 3 generators&gt; ),\n  [ 2, 0, 0, -2, 0 ] ) ]\ngap&gt; k := 1;; Sum( List( irr, x-&gt;x[3]^k/x[1]^(k-2) ));\n0\ngap&gt; k := 2;; Sum( List( irr, x-&gt;x[3]^k/x[1]^(k-2) ));\n4\nNote que obtemos que o ordem generalizada de \\(a\\) é \\(2\\). Note que a ordem do mesmo elemento é \\(4\\).",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Carateres de um grupo e a ordem generalizada</span>"
    ]
  },
  {
    "objectID": "genord.html#tarefa-1",
    "href": "genord.html#tarefa-1",
    "title": "14  Carateres de um grupo e a ordem generalizada",
    "section": "14.3 Tarefa 1",
    "text": "14.3 Tarefa 1\n\n\nEscreva uma função generalized_order( G, i ) que dado um grupo \\(G\\) e \\(i\\geq 1\\), devolve a ordem generalizada de um elemento na \\(i\\)-ésima class de conjugação de \\(G\\) usando a equação Equação 14.1.\n\nEscreva uma função generalized_orders( G ) que calcula a lista das ordens generalizadas das classes de conjugação de \\(G\\).\n\nO resultado do seu código deve seguir os seguintes exemplos.\ngap&gt; generalized_order( SymmetricGroup( 5 ), 2 );\n2\ngap&gt; generalized_order( SmallGroup( 18, 3 ), 2 );\n2\ngap&gt; generalized_order( SmallGroup( 18, 3 ), 5 );\n6\ngap&gt; generalized_orders( AlternatingGroup( 5 ));\n[ 1, 2, 2, 2, 2 ]\ngap&gt; generalized_orders( AlternatingGroup( 7 ));\n[ 1, 2, 2, 2, 2, 2, 2, 3, 3 ]\n\n\nCalcule a soma na equação Equação 14.1 para todo \\(k\\) até ela vira não nula. Usa o laço repeat (Seção 5.4).",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Carateres de um grupo e a ordem generalizada</span>"
    ]
  },
  {
    "objectID": "genord.html#tarefa-2",
    "href": "genord.html#tarefa-2",
    "title": "14  Carateres de um grupo e a ordem generalizada",
    "section": "14.4 Tarefa 2",
    "text": "14.4 Tarefa 2\n\n\nUsando as funções na tarefa anterior, ache um grupo \\(G\\) que possui elemento \\(x\\in G\\) tal que \\([x]\\) não é divisor de \\(|G|\\).\nAche um grupo \\(G\\) que possui um elemento \\(x\\in G\\) tal que \\([x]\\) é coprimo com \\(|G|\\).\nAche um grupo \\(G\\) que possui um elemento \\(x\\in G\\) tal que \\([x]\\) é um primo \\(p\\) tal que \\(p\\nmid |G|\\).\n\n\n\nEscreva uma função para cada um dos itens nesta tarefa. A função deve devolver true se o grupo sataisfaz a condição procurada, e false caso contrário. Use Filtered sobre AllSmallGroups( Size, list ) (veja a Seção 3.1).",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Carateres de um grupo e a ordem generalizada</span>"
    ]
  },
  {
    "objectID": "algebras.html",
    "href": "algebras.html",
    "title": "15  Anéis e álgebras",
    "section": "",
    "text": "15.1 Idempotentes e elementos nilpotentes em \\(\\mathbb Z_n\\)",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Anéis e álgebras</span>"
    ]
  },
  {
    "objectID": "algebras.html#idempotentes-e-elementos-nilpotentes-em-mathbb-z_n",
    "href": "algebras.html#idempotentes-e-elementos-nilpotentes-em-mathbb-z_n",
    "title": "15  Anéis e álgebras",
    "section": "",
    "text": "Seja \\(n\\geq 2\\) um inteiro e consideramos o anel \\(\\mathbb Z_n\\) de inteiros moduló \\(n\\) com a adição e multiplicação usuais. Em GAP esse anel pode ser construído como no seguinte exemplo.\ngap&gt; R := ZmodnZ(12 );\n(Integers mod 12)\nPara acessar os elementos de R, precisamos considerar \\(a\\cdot 1_R\\) onde \\(1_R\\) é a identidade de \\(R\\). Por exemplo, o elemento 3 em R pode ser escrito nesta forma.\ngap&gt; a := 3*One( R );\nZmodnZObj( 3, 12 )",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Anéis e álgebras</span>"
    ]
  },
  {
    "objectID": "algebras.html#tarefa-1",
    "href": "algebras.html#tarefa-1",
    "title": "15  Anéis e álgebras",
    "section": "15.2 Tarefa 1",
    "text": "15.2 Tarefa 1\n\nUm elemento \\(a\\in\\mathbb Z_n\\) chama-se nilpotente se \\(a^k=0\\) com algum \\(k\\geq 1\\) e o menor tal \\(k\\) é chamado de grau de nilpotência de \\(a\\). Um elemento \\(a\\in\\mathbb Z_n\\) chama-se idempotente se \\(a^2=a\\).\ngap&gt; a := 3*One( R );\n3\ngap&gt; IsIdempotent( a );\nfalse\n\nEscreva uma função nr_idempotents_of_zn( n ) que devolve o número de idempotentes em \\(\\mathbb Z_n\\).\nUse a função escrita no item anterior para calcular o número de idempotentes em anéis na forma \\(\\mathbb Z_{p^n}\\) onde \\(p\\) é primo. Formalize uma conjetura.\nEscreva uma função que determina se um elemento de \\(\\mathbb Z_n\\) é nilpotente.\nEscreva uma função que devolve o número de elementos nilpotentes em \\(\\mathbb Z_n\\). Experimente a função com vários valores de \\(n\\) e tente formalizar uma conjetura.\n\n\n\nUse a função IsIdempotent e Filtered (Seção 3.1). Para verificar se um elemento é nilpotente, observe que \\(a\\in\\mathbb Z_n\\) é nilpotente se e somente se \\(a^n=0\\). Pense se dâ para verificar a nilpotência de \\(a\\) usando um expoente menor.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Anéis e álgebras</span>"
    ]
  },
  {
    "objectID": "algebras.html#a-álgebra-dos-quaternions",
    "href": "algebras.html#a-álgebra-dos-quaternions",
    "title": "15  Anéis e álgebras",
    "section": "15.3 A álgebra dos quaternions",
    "text": "15.3 A álgebra dos quaternions\n\nSeja \\(\\mathbb F\\) um corpo e \\(\\alpha,\\ \\beta\\in\\mathbb  F\\setminus\\{0\\}\\). A álgebra generalizada dos quatérnions \\(A_{\\alpha,\\beta}\\) é um espaço vetorial de dimensão 4 sobre \\(\\mathbb F\\) gerado com a base \\(B=[1,i,j,k]\\) munido com a multiplicação dada por a tabela seguinte:\n\n\n\n\\(\\cdot\\)\n\\(1\\)\n\\(i\\)\n\\(j\\)\n\\(k\\)\n\n\n\n\n\\(1\\)\n\\(1\\)\n\\(i\\)\n\\(j\\)\n\\(k\\)\n\n\n\\(i\\)\n\\(i\\)\n\\(\\alpha\\)\n\\(k\\)\n\\(\\alpha j\\)\n\n\n\\(j\\)\n\\(j\\)\n\\(-k\\)\n\\(\\beta\\)\n\\(-\\beta i\\)\n\n\n\\(k\\)\n\\(k\\)\n\\(-\\alpha j\\)\n\\(\\beta i\\)\n\\(-\\alpha \\beta\\)\n\n\n\nA álgebra usual dos quaternions pode ser obtida como \\(A_{-1,-1}\\).\n\n\nVamos construir \\(A_{1,1}\\). Em GAP tal álgebras podem ser construídas com a função AlgebraByStructureConstants. Primeiro nós inicializamos \\(T\\) como uma tabela vazia de constantes de estrutura.\ngap&gt; T := EmptySCTable( 4, 0 );\n[ [ [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ] ], \n  [ [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ] ], \n  [ [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ] ], \n  [ [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ] ], 0, 0 ]\nO primeiro argumento de EmptySCTable é a dimensão da álgebra, o segundo argumento é um zero no domínio de coeficientes.\nA multiplicação em \\(A_{1,1}\\) pode ser definida da maneira seguinte. Primeiro o produto \\(1\\cdot 1=1\\) é definido usando SetEntrySCTable.\ngap&gt; SetEntrySCTable( T, 1, 1, [1,1] );\nO primeiro argumento é o nome da tabela em que definimos o produto. O segundo e o terceiro argumentos significam que definimos o produto B[1]•B[1]. O último argumento significa que o produto é 1•B[1].\nContinuando desta maneira, definimos os produtos de \\(A_{1,1}\\).\n SetEntrySCTable( T, 1, 2, [1,2] );\n SetEntrySCTable( T, 1, 3, [1,3] );\n SetEntrySCTable( T, 1, 4, [1,4] );\n SetEntrySCTable( T, 2, 1, [1,2] );\n SetEntrySCTable( T, 2, 2, [1,1] );\n SetEntrySCTable( T, 2, 3, [1,4] );\n SetEntrySCTable( T, 2, 4, [1,3] );\n SetEntrySCTable( T, 3, 1, [1,3] );\n SetEntrySCTable( T, 3, 2, [-1,4] );\n SetEntrySCTable( T, 3, 3, [1,1] );\n SetEntrySCTable( T, 3, 4, [-1,2] );\n SetEntrySCTable( T, 4, 1, [1,4] );\n SetEntrySCTable( T, 4, 2, [-1,3] );\n SetEntrySCTable( T, 4, 3, [1,2] );\n SetEntrySCTable( T, 4, 4, [-1,1] );\n A := AlgebraByStructureConstants( F, T );",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Anéis e álgebras</span>"
    ]
  },
  {
    "objectID": "algebras.html#tarefa-2",
    "href": "algebras.html#tarefa-2",
    "title": "15  Anéis e álgebras",
    "section": "15.4 Tarefa 2",
    "text": "15.4 Tarefa 2\n\n\nEscreva uma função quaternion_algebra( F, a, b ) que devolve a álgebra de quatérnions \\(A_{a,b}\\) sobre \\(\\mathbb F\\).\nUse a função quaternion_algebra para construir várias álgebras sobre vários corpos. Verifique se as álgebras são simples (use IsSimpleAlgebra).",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Anéis e álgebras</span>"
    ]
  },
  {
    "objectID": "groebner1.html",
    "href": "groebner1.html",
    "title": "16  Polynômios, ideais, e um problema de triângulos",
    "section": "",
    "text": "16.1 Polynômios em GAP",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Polynômios, ideais, e um problema de triângulos</span>"
    ]
  },
  {
    "objectID": "groebner1.html#polynômios-em-gap",
    "href": "groebner1.html#polynômios-em-gap",
    "title": "16  Polynômios, ideais, e um problema de triângulos",
    "section": "",
    "text": "Indeterminados, polinômios e anéis de polinômios podem ser definidos em GAP na maneira seguinte.\ngap&gt; x := Indeterminate( Rationals, \"x\" );\nx\ngap&gt; y := Indeterminate( Rationals, \"y\" );\ny\ngap&gt; z := Indeterminate( Rationals, \"z\" );\nz\ngap&gt; P := PolynomialRing( Rationals, [x,y,z] );\nRationals[x,y,z]\ngap&gt; f := x*y-z^2;\nx*y-z^2\ngap&gt; g := x^2+z^2;\nx^2+z^2\ngap&gt; f*g;\nx^3*y-x^2*z^2+x*y*z^2-z^4\nNote que podemos também definir ideais\ngap&gt; I := Ideal( P, [f,g] );\n&lt;two-sided ideal in Rationals[x,y,z], (2 generators)&gt;\nConsidere \\[\nh=x^2yz-xz^3-x^3-xz^2+xy-z^2.\n\\] Verifiquemos se \\(h\\) pertence ao ideal \\(I=(f,g)\\).\ngap&gt; h := h=x^2*y*z-x*z^3-x^3-x*z^2+x*y-z^2;\ngap&gt; I := Ideal( P, [f,g] );\n&lt;two-sided ideal in Rationals[x,y,z], (2 generators)&gt;\ngap&gt; h in I;\ntrue\nPortanto \\(h\\) pode ser escrito na forma \\[\nh=uf+vg\\quad\\mbox{com}\\quad u,v\\in\\mathbb Q[x,y,z].\n\\] Vamos ver como achar os polinômios \\(u\\) e \\(v\\).\ngap&gt; PolynomialReduction( h, [f,g], MonomialLexOrdering() );\n[ 0, [ x*z+1, -x ] ]\nO resultado indica que o resto de \\(h\\) em relação ao ideal \\(I\\) é \\(0\\) e os dois polinômios do segundo componente do output podem ser tomados para \\(u\\) e \\(v\\).\ngap&gt; h = (x*z+1)*f-x*g\ntrue",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Polynômios, ideais, e um problema de triângulos</span>"
    ]
  },
  {
    "objectID": "groebner1.html#as-medianas-de-um-triângulo",
    "href": "groebner1.html#as-medianas-de-um-triângulo",
    "title": "16  Polynômios, ideais, e um problema de triângulos",
    "section": "16.2 As medianas de um triângulo",
    "text": "16.2 As medianas de um triângulo\n\nSeja \\(\\Delta=ABC\\) um triângulo no plano. A reta que conecta uma ponta de \\(\\Delta\\) com o ponto meio do lado oposto chama-se mediana. Está bem conhecido que as medianas se interceptam em um ponto chamado de baricentro de \\(\\Delta\\). Neste projeto provaremos este fato usando álgebra comutativa.\nAssuma sem perder generalidade que as três pontas do triângulo são \\[\\begin{align*}\nA & = (0,0);\\\\\nB & = (1,0);\\\\\nC & = (x,y).\n\\end{align*}\\] Assuma que \\(P\\), \\(Q\\) e \\(R\\) são os pontos médios dos lados \\(BC\\), \\(AC\\) e \\(AB\\). Portanto, \\[\\begin{align*}\nP & = ((x+1)/2,y/2);\\\\\nQ & = (x/2,y/2);\\\\\nR & = (1/2,0).\n\\end{align*}\\] Assuma que \\(S=(u,v)\\) é o ponto de interseção das retas \\(AP\\) e \\(BQ\\). Precisa provar que a reta \\(CR\\) passa pelo ponto \\(S\\). Os fatos que \\(S\\) está na reta \\(AP\\) e que \\(S\\) está na reta \\(BQ\\) podem ser expressas das equações \\[\\begin{align*}\n\\frac uv=\\frac{x+1}y;\\\\\n\\frac{x-2}y=\\frac{u-1}v.\n\\end{align*}\\] Como o triângulo não é degenerado, temos que \\(u\\neq 0\\), \\(v\\neq 0\\) e \\(y\\neq 0\\) e estas equações são equivalentes com as equações \\[\\begin{align*}\nf_1&=uy-v(x+1)=0;\\\\\nf_2&=(x-2)u-(u-1)y=0.\n\\end{align*}\\] Similarmente, o fato que \\(S\\) está na reta \\(CR\\) pode ser expressa pela equação \\[\n\\frac{u-1/2}v=\\frac{x-1/2}y;\n\\] ou seja, \\[\nf_3=-2xv+2yu-y+v=0.\n\\]\nPara provar que \\(S\\) está na reta \\(CR\\), é suficiente provar que que \\[\nf_3\\in(f_1,f_2).\n\\]",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Polynômios, ideais, e um problema de triângulos</span>"
    ]
  },
  {
    "objectID": "groebner1.html#tarefa-1",
    "href": "groebner1.html#tarefa-1",
    "title": "16  Polynômios, ideais, e um problema de triângulos",
    "section": "16.3 Tarefa 1",
    "text": "16.3 Tarefa 1\n\nFaça as seguintes computações com GAP.\n\nDefina o anel de polinômios \\(\\mathbb Q[x,y,u,v]\\).\nDefina os polinômios \\(f_1,f_2,f_3\\) em cima.\nVerifique se \\(f_3\\in(f_1,f_2)\\).\nEscreva \\(f_3\\) na forma \\[\nf_3=h_1f_1+h_2f_2\n\\] onde \\(h_i\\in\\mathbb Q[x,y,u,v]\\).\n\n\n\nSegue os passos na computação em cima.",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Polynômios, ideais, e um problema de triângulos</span>"
    ]
  },
  {
    "objectID": "groebner1.html#tarefa-2",
    "href": "groebner1.html#tarefa-2",
    "title": "16  Polynômios, ideais, e um problema de triângulos",
    "section": "16.4 Tarefa 2",
    "text": "16.4 Tarefa 2\n\nO modelo algébrico não incluiu a informação que o triângulo é não degenerado; ou seja, \\(y\\neq 0\\). Esta condição pode ser incluída no modelo por introduzir uma nova variável \\(Y\\) e uma nova equação \\[\nf_4=Yy-1=0.\n\\]\n\nFaça as computações na Tarefa 1 incluindo o polinômio \\(f_4\\). Verifique se o resultado é diferente.",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Polynômios, ideais, e um problema de triângulos</span>"
    ]
  },
  {
    "objectID": "groebner1.html#tarefa-3",
    "href": "groebner1.html#tarefa-3",
    "title": "16  Polynômios, ideais, e um problema de triângulos",
    "section": "16.5 Tarefa 3",
    "text": "16.5 Tarefa 3\n\nDemonstre que o ponto \\(S\\) divide as medianas em duas partes cuja razão é \\(1:2\\). Note que esta afirmação é equivalente à equação \\[\n3|RS|=3(u-1/2,v)=(x-1/2,y)=|RC|.\n\\] Ou seja, precisa verificar que \\[\n3u-x-1,\\ 3v-y\\in (f_1,f_2).\n\\]\n\nVerifique se estes dois polinômios estão no ideal \\((f_1,f_2)\\).\nEscreve-os na forma \\[\nh_1f_1+h_2f_2.\n\\]",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Polynômios, ideais, e um problema de triângulos</span>"
    ]
  },
  {
    "objectID": "groebner.html",
    "href": "groebner.html",
    "title": "17  Dependência algébrica de polinômios",
    "section": "",
    "text": "17.1 Dependência algêbrica",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Dependência algébrica de polinômios</span>"
    ]
  },
  {
    "objectID": "groebner.html#sec-groebner-problem",
    "href": "groebner.html#sec-groebner-problem",
    "title": "17  Dependência algébrica de polinômios",
    "section": "",
    "text": "Assuma que \\(f_1,\\ldots,f_k\\) são polinômios em um anel \\(\\mathbb F[x_1,\\ldots,x_n]\\) de polinômios sobre um corpo \\(\\mathbb F\\). Dizemos que \\(f_1,\\ldots,f_k\\) são algebricamente dependentes se existir um polinômio \\(h(t_1,\\ldots,t_k)\\in\\mathbb F[t_1,\\ldots,t_k]\\) tal que \\[\nh(f_1,\\ldots,f_k)=0.\n\\] Um polinômio \\(f\\in\\mathbb F[x_1,\\ldots,x_n]\\) pertence à álgebra \\(\\mathbb F[f_1,\\ldots,f_k]\\) gerada por \\(f_1,\\ldots,f_k\\) se existir um polinômio \\(h(t_1,\\ldots,t_k)\\in\\mathbb F[t_1,\\ldots,t_k]\\) tal que \\[\nf=h(f_1,\\ldots,f_k).\n\\] Note que \\(f\\in\\mathbb F[f_1,\\ldots,f_k]\\) implica que \\(f,f_1,\\ldots,f_k\\) são algebricamente dependentes.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Dependência algébrica de polinômios</span>"
    ]
  },
  {
    "objectID": "groebner.html#exploração-interativa",
    "href": "groebner.html#exploração-interativa",
    "title": "17  Dependência algébrica de polinômios",
    "section": "17.2 Exploração interativa",
    "text": "17.2 Exploração interativa\n\nConsidere por exemplo os seguintes polinômios em \\(\\mathbb Q[y_0,y_1,y_2,y_3]\\): \\[\\begin{align*}\nf_1&=y_0;\\\\\nf_2&=2y_0y_2-y_1^2;\\\\\nf_3&=3y_0^2y_3-3y_0y_1y_2+y_1^3\\\\\nf_4&=-3y_1^2y_2^2+8y_0y_2^3+6y_1^3y_3-18y_0y_1y_2y_3+9y_0^2y_3^2.\n\\end{align*}\\]\nVamos verificar que estes polinômios são algebricamente dependentes. Primeiro, vamos construir a álgebra de polinômios.\ngap&gt; y0 := Indeterminate( Rationals, \"y0\" );\ny0\ngap&gt; y1 := Indeterminate( Rationals, \"y1\" );\ny1\ngap&gt; y2 := Indeterminate( Rationals, \"y2\" );\ny2\ngap&gt; y3 := Indeterminate( Rationals, \"y3\" );\ny3\ngap&gt; P := PolynomialRing( Rationals, [y0,y1,y2,y3] );\nRationals[y0,y1,y2,y3]\nOra, vamos construir os polinômios.\ngap&gt; f1 := y0;\ny0\ngap&gt; f2 := 2*y0*y2-y1^2;\n2*y0*y2-y1^2\ngap&gt; f3 := 3*y0^2*y3-3*y0*y1*y2+y1^3;\n3*y0^2*y3-3*y0*y1*y2+y1^3\ngap&gt; f4 := -3*y1^2*y2^2+8*y0*y2^3+6*y1^3*y3-18*y0*y1*y2*y3+9*y0^2*y3^2;\n9*y0^2*y3^2-18*y0*y1*y2*y3+8*y0*y2^3+6*y1^3*y3-3*y1^2*y2^2\nO truque é introduzir novas variáveis, \\(t_1\\), \\(t_2\\), \\(t_3\\), \\(t_4\\) (uma para cada polinômio no sistema) e computar uma base de Groebner para o ideal \\[\n(t_1-f_1,t_2-f_2,t_3-f_3,t_4-f_4).\n\\]\ngap&gt; t1 := Indeterminate( Rationals, \"t1\" );\nt1\ngap&gt; t2 := Indeterminate( Rationals, \"t2\" );\nt2\ngap&gt; t3 := Indeterminate( Rationals, \"t3\" );\nt3\ngap&gt; t4 := Indeterminate( Rationals, \"t4\" );\nt4\ngap&gt; P1 := PolynomialRing( Rationals, [y0,y1,y2,y3,t1,t2,t3,t4] );\nRationals[y0,y1,y2,y3,t1,t2,t3,t4]\ngap&gt; I := Ideal( P1, [t1-f1,t2-f2,t3-f3,t4-f4] );\n&lt;two-sided ideal in Rationals[y0,y1,y2,y3,t1,t2,t3,t4], (4 generators)&gt;\ngap&gt; G := GroebnerBasis( I, MonomialLexOrdering );\n[ t1^2*t4-t2^3-t3^2, y2^3*t2^3-9/2*y3^2*t1*t2^3+y2^3*t3^2+3/2*y2^2*t1*t2*t4-9/2*y3^2*t1*t3^2+3*y3*t1*t3*t4-1/2*t1*t4^2, y2^3*t1-9/2*y3^2*t1^2+3/2*y2^2*t2+3*y3*t3-1/2*t4, \n  y1*y3*t2^3-2/3*y2^2*t2^3+y1*y3*t3^2-2/3*y2^2*t3^2-1/3*y2*t1*t2*t4-1/3*y1*t3*t4+1/3*t2^2*t4, y1*y3*t1^2-2/3*y2^2*t1^2-1/3*y2*t1*t2-1/3*y1*t3+1/3*t2^2, \n  3*y1*y3*t1*t2-2*y2^2*t1*t2+y1*y2*t3-y2*t2^2-3*y3*t1*t3+t1*t4, y1*y2*t2^2-3*y1*y3*t1*t3+2*y2^2*t1*t3-3*y3*t1*t2^2+y1*t1*t4+y2*t2*t3, y1*y2*t1-3*y3*t1^2+y1*t2+t3, \n  y1*y2^2*t2-3*y2*y3*t1*t2+3*y1*y3*t3-2*y2^2*t3+3*y3*t2^2-y1*t4, y1^2-2*y2*t1+t2, y0-t1 ]\nNote que G[1] é um polinômio na variáveis \\(t_1,t_2,t_3,t_4\\) apenas. Este polinômio expressa a dependência algébrica entre \\(f_1,f_2,f_3,f_4\\).\ngap&gt; h := G[1];\nt1^2*t4-t2^3-t3^2\ngap&gt; Value( h, [t1,t2,t3,t4], [f1,f2,f3,f4] );\n0\nQuando a base de Groebner tem muitos polinômios, conseguimos achar o polinômio certo usando a seguinte instrução:\ngap&gt; Filtered( G, x-&gt; DegreeIndeterminate( x, y0 ) = 0 and DegreeIndeterminate( x, y1 ) = 0 and DegreeIndeterminate( x, y2 ) = 0 and DegreeIndeterminate( x, y3 ) = 0 );\n[ t1^2*t4-t2^3-t3^2 ]",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Dependência algébrica de polinômios</span>"
    ]
  },
  {
    "objectID": "groebner.html#a-teoria-da-computação-anterior.",
    "href": "groebner.html#a-teoria-da-computação-anterior.",
    "title": "17  Dependência algébrica de polinômios",
    "section": "17.3 A teoria da computação anterior.",
    "text": "17.3 A teoria da computação anterior.\nA computação anterior está baseada na seguinte teorema.\n\nTeorema 17.1 Usando a notação da Seção 17.1, seja \\(\\mathcal G\\) uma base de Groebner do ideal \\[\nI=(t_1-f_1,\\ldots,t_k-f_k)\n\\] relativa a uma ordem monomial na qual \\(x_1&gt;x_2\\cdots&gt;x_n&gt;t_1&gt;\\cdots&gt;t_k\\). As seguintes afirmações são verdadeiras.\n\n\\(f_1,\\ldots,f_k\\) são algebricamente dependentes se e somente se existe \\(h\\in\\mathcal G\\cap \\mathbb F[t_1,\\ldots,t_k]\\). Neste caso, \\(h(f_1,\\ldots,f_k)=0\\).\n\n\\(f_1\\in\\mathbb F[f_2,\\ldots,f_k]\\) se e somente se \\(\\mathcal G\\) possui um elemento na forma \\(h=t_1+h_1\\) onde \\(h_1\\in \\mathbb F[t_2,\\ldots,t_k]\\). Neste caso, \\(f=h(f_2,\\ldots,f_k)\\).\n\n\nA demonstração do Teorema não é muito difícil, ela dependa da Fórmula de Taylor para polinômios multivariáveis sobre anel arbitrário.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Dependência algébrica de polinômios</span>"
    ]
  },
  {
    "objectID": "groebner.html#tarefa-1",
    "href": "groebner.html#tarefa-1",
    "title": "17  Dependência algébrica de polinômios",
    "section": "17.4 Tarefa 1",
    "text": "17.4 Tarefa 1",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Dependência algébrica de polinômios</span>"
    ]
  },
  {
    "objectID": "groebner.html#tarefa-2",
    "href": "groebner.html#tarefa-2",
    "title": "17  Dependência algébrica de polinômios",
    "section": "17.5 Tarefa 2",
    "text": "17.5 Tarefa 2\n\n\nEscreva uma função is_alg_dependent( list ) que devolve um polinômio h tal que \\(h(f_1,\\ldots,f_k)=0\\) com \\(f_1,\\ldots,f_k\\) sendo oselmenentos na lista list. Se os polinômios da lista são algebricamente dependentes, a função deve devolver um polinômio não nulo. Caso contrário, a função deve devolver o polinômio nulo.\nEscreva uma função is_member_of_subalgebra( f, list ) que decide se \\(f\\) é membro da subálgebra gerada pelos polinômios em list. Caso afirmativo, a função deve devolver um polinômio \\(h\\) tal que \\(f=h(f_1,\\ldots,f_k)\\) onde \\(f_1,\\ldots,f_k\\) são os elementos de list. Caso contrário, a função deve devolver fail.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Dependência algébrica de polinômios</span>"
    ]
  },
  {
    "objectID": "grafos.html",
    "href": "grafos.html",
    "title": "18  Grafos em GAP",
    "section": "",
    "text": "18.1 O grafo de Petersen",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Grafos em GAP</span>"
    ]
  },
  {
    "objectID": "grafos.html#o-grafo-de-petersen",
    "href": "grafos.html#o-grafo-de-petersen",
    "title": "18  Grafos em GAP",
    "section": "",
    "text": "O grafo de Petersené um grafo com muitas propriedades interessantes. O grafo de Petersen pode ser construído como o grafo com o conjunto de vértices \\[\nV=\\{\\{x,y\\}\\mid 1\\leq x&lt;y\\leq 5\\}\n\\] onde dois vértices \\(\\{x,y\\}\\) e \\(\\{u,v\\}\\) são conectados se e só se \\(\\{x,y\\}\\cap \\{u,v\\}=\\emptyset\\).\nVamos construir o grafo de Petersen em GAP. Primeiro construímos o conjunto de vértices.\ngap&gt; ver := Combinations( [1..5], 2 );\n[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 2, 3 ], [ 2, 4 ], [ 2, 5 ], \n  [ 3, 4 ], [ 3, 5 ], [ 4, 5 ] ]\nO conjunto de vértices de um grafo em GAP tem de ser uma lista [1..k]. No nosso caso, o conjunto de vértices será [1..10]. Dois vértices i e j serão conexos se Intersection( ver[i], ver[j] ) = [].\ngap&gt; ares := [];\ngap&gt; for i in [1..10] do\n&gt; for j in [1..10] do\n&gt; if Intersection( ver[i], ver[j] ) = [] then\n&gt; Add( ares, [i,j] );\n&gt; fi;\n&gt; od;\n&gt; od;\ngap&gt; ares;\n[ [ 1, 8 ], [ 1, 9 ], [ 1, 10 ], [ 2, 6 ], [ 2, 7 ], [ 2, 10 ], [ 3, 5 ], \n  [ 3, 7 ], [ 3, 9 ], [ 4, 5 ], [ 4, 6 ], [ 4, 8 ], [ 5, 3 ], [ 5, 4 ], \n  [ 5, 10 ], [ 6, 2 ], [ 6, 4 ], [ 6, 9 ], [ 7, 2 ], [ 7, 3 ], [ 7, 8 ], \n  [ 8, 1 ], [ 8, 4 ], [ 8, 7 ], [ 9, 1 ], [ 9, 3 ], [ 9, 6 ], [ 10, 1 ], \n  [ 10, 2 ], [ 10, 5 ] ]\nPara construir o grafo de Petersen, nós precisamos do pacote GRAPE de GAP. O grafo vai ser construído pela função\n\ngap&gt; LoadPackage( \"grape\" );\ntrue\ngap&gt; EdgeOrbitsGraph( Group(()), ares, 10 );\nrec( adjacencies := [ [ 8, 9, 10 ], [ 6, 7, 10 ], [ 5, 7, 9 ], [ 5, 6, 8 ], \n      [ 3, 4, 10 ], [ 2, 4, 9 ], [ 2, 3, 8 ], [ 1, 4, 7 ], [ 1, 3, 6 ], \n      [ 1, 2, 5 ] ], group := Group(()), isGraph := true, order := 10, \n  representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ], \n  schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10 ] )\ngap&gt; \ngap&gt; IsConnectedGraph( G );\ntrue\ngap&gt; Diameter( G );\n2\ngap&gt; Girth( G );\n5\ngap&gt; IsConnectedGraph( G );\ntrue",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Grafos em GAP</span>"
    ]
  },
  {
    "objectID": "grafos.html#tarefa",
    "href": "grafos.html#tarefa",
    "title": "18  Grafos em GAP",
    "section": "18.2 Tarefa",
    "text": "18.2 Tarefa\n\nSe \\(G\\) é um grupo, então definimos o grafo não comutante de \\(G\\) como sendo o grafo cujo conjunto de vértices é \\(G\\setminus Z(G)\\) e dois vertices \\(g,\\ h\\) são conectados se e só se \\(xy\\neq yx\\); ou seja, \\([x,y]=x^{-1}y^{-1}xy\\neq 1\\).\n\nEscreva uma função non_commuting_graph( G ) que devolve o grafo não comutante para um grupo finito \\(G\\).\nUse a função non_commuting_graph( G ) para investigar grafos associados a grupos finitos de ordem pequena (use a função SmallGroup). Verifique se os grafos são conexos, determine o diâmetro.\n\nAlgumas propriedades interessentas de grafos não comutantes são demonstradas neste artigo.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Grafos em GAP</span>"
    ]
  }
]