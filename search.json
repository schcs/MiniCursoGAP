[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Álgebra Computacional com GAP",
    "section": "",
    "text": "1 MiniCursoGAP\nMaterial para minicurso de GAP na Escola de Álgebra em São Paulo (2024).\n\nRodar o sistema, criar, salvar e carregar arquivos\nAritmética básica, variáveis, funções\nO primeiro encontro com estruturas algébricas\nA linguagem de programação\nListas, matrizes, permutações\nA Conjetura de Collatz\nConceitos básicos com grupos\nHomomorfismos, automorfismos, etc, de grupos\nComutadores de grupos\nGrupos livres, homomorfismos, Exploração do cubo mágico\nGrupos de permutação\nGrupos de matrizes\nÁlgebras de Lie\nÁlgebras associativas\nÁlgebra comutativa\nBases de Grobner\nTeoria de Galois\nTeoria de grafos",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>MiniCursoGAP</span>"
    ]
  },
  {
    "objectID": "arith.html",
    "href": "arith.html",
    "title": "2  Aritmética básica",
    "section": "",
    "text": "2.0.1 Operações aritméticas\n\nAs operações mais comuns em GAP são + (adição), - (subtração), * (multiplicação), / (divisão), mod, ^ (exponenciação). Considere os seguintes exemplos\ngap&gt; 2+3;\n5\ngap&gt; 2/4;\n1/2\ngap&gt; (2+3)*(1/2);\n5/2\ngap&gt; 2^3*3;\n24\ngap&gt; 2^-2*3;\n3/4\ngap&gt; 2.0;\n2.\ngap&gt; 2.01+3.11;\n5.12\ngap&gt; 1/3;\n1/3\ngap&gt; 1.0/3;\n0.333333\n\nNote a diferença de trabalhar com valores exatos (como por exemplo 1/3) e valores aproximados (por exemplo 1.0/3).\nQuando trabalhamos com estruturas algébricas, precisamos trabalhar com corpos além do corpo \\(\\mathbb Q\\). Aqui em baixo veremos alguns exemplos para aritmética com corpos finitos.\ngap&gt; F := GF(11);\nGF(11)\ngap&gt; e := One( F );\nZ(11)^0\ngap&gt; z := Zero( F );\n0*Z(11)\ngap&gt; p := PrimitiveElement( F );\nZ(11)\ngap&gt; e+p;\nZ(11)^8\ngap&gt; e+p^2;\nZ(11)^4\ngap&gt; IntFFE( e+p^2 );\n5\n\n\n2.0.2 Variáveis\nAs variáveis guardam valores. Uma variável é um string de letras, números e alguns carateres especiais. Aqui é um exemplo simples.\ngap&gt; 3a := 2;\n2\ngap&gt; _3a := 2;\n2\ngap&gt; a := 2; \n2\ngap&gt; b := 3;\n3\ngap&gt; a + b; a*b;\n5\n6\nVariávies podem conter valores mais complexos, como nos seguintes exemplos.\ngap&gt; s1 := \"Hello\";\n\"Hello\"\ngap&gt; s2 := \" World!\";\n\" World!\"\ngap&gt; Concatenation( s1, s2 );\n\"Hello World!\"\n\n\n2.0.3 Funções\nFunções em GAP podem ser usadas para realizar computações que queremos fazer várias vezes com diferentes objetos. Por exemplo a função que, dado x computa 3*x+1 pode ser definida de duas maneiras diferentes.\ngap&gt; f1 := function( x )\n&gt; return 3*x+1;\n&gt; end;\nfunction( x ) ... end\ngap&gt; f2 := x -&gt; 3*x + 1;\nfunction( x ) ... end\ngap&gt; f1 = f2;\nfalse\ngap&gt; f1( 5 );\n16\ngap&gt; f2( -2 );\n-5\nNos exemplos anteriores, a função não precisa de variáveis adicionais para executar sua tarefa. Isso pode acontecer com funções simples, mas uma função mais complicada pode precisar introduzir as suas próprias variáveis, chamadas de variáveis locais. Considere a seguinte implementação do exemplo em cima.\ngap&gt; f3 := function( x )\n&gt; local y;\n&gt; y := 3*x;\n&gt; return y+1;\n&gt; end;\nfunction( x ) ... end\ngap&gt; f3(4);\n13\ngap&gt; y;\nError, Variable: 'y' must have a value\nnot in any function at *stdin*:44\nAs últimas linhas do exemplo anterior mostram que o variável y não está visível fora da função. Isso permite que variáveis com o mesmo nome sejam usadas em várias funções sem que sejam confundidas. O mesmo também impede que a varíavel local y definida dentro da função f3 seja confundida com uma possível variável global também chamada de y. O seguinte código mostra que o nome y tem significado diferente dentro e fora da função.\ngap&gt; f3 := function( x )\n&gt; local y;\n&gt; y := 3*x;\n&gt; Print( \"O valor de y é \", y, \"\\n\" );\n&gt; return y+1;\n&gt; end;\nfunction( x ) ... end\ngap&gt; y := -5;\n-5\ngap&gt; f3(10);\nO valor de y é 30\n31\ngap&gt; y;\n-5\n\n\n2.0.4 Listas e Matrizes\nListas são importantes em GAP. Listas contém uma sequência de objetos. Os objetos nas listas podem ser números, carateres, ou até objetos complexos, tais como grupos, subgrupos de um grupo, etc. Os seguintes exemplos mostram a criação de listas e as operações básicas com listas.\ngap&gt; L1 := [1,3,5,7,9,10,8,6,4,2,0];\n[ 1, 3, 5, 7, 9, 10, 8, 6, 4, 2, 0 ]\ngap&gt; L2 := [\"a\",\"b\",\"c\",\"z\",\"x\",\"y\"];\n[ \"a\", \"b\", \"c\", \"z\", \"x\", \"y\" ]\ngap&gt; L1[3];\n5\ngap&gt; 10 in L1;\ntrue\ngap&gt; 10 in L2;\nfalse\ngap&gt; \"a\" in L2;\ntrue\ngap&gt; Union( L1, L2 );\n[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, \"a\", \"b\", \"c\", \"x\", \"y\", \"z\" ]\ngap&gt; Position( L1, 10 );\n6\ngap&gt; Position( L1, -1 );\nfail\ngap&gt; Intersection( L1, L2 );\n[  ]\ngap&gt; Filtered( L, x -&gt; x mod 2 = 0 );\nError, Variable: 'L' must have a value\nnot in any function at *stdin*:2\ngap&gt; Filtered( L1, x -&gt; x mod 2 = 0 );\n[ 10, 8, 6, 4, 2, 0 ]\ngap&gt; Filtered( L1, x -&gt; x mod 2 = 1 );\n[ 1, 3, 5, 7, 9 ]\ngap&gt; Filtered( L1, x -&gt; IsEvenInt( x ));\n[ 10, 8, 6, 4, 2, 0 ]\ngap&gt; Filtered( L1, x -&gt; IsOddInt( x ));\n[ 1, 3, 5, 7, 9 ]\ngap&gt; Filtered( L1, IsEvenInt );\n[ 10, 8, 6, 4, 2, 0 ]\ngap&gt; Filtered( L1, IsOddInt );\n[ 1, 3, 5, 7, 9 ]\ngap&gt; \nListas podem ser criadas usando outras listas. Por exemplo, criamos a list dos quadrados dos primeiros 10 números naturais:\ngap&gt; List( [1..10], x-&gt;x^2 );\n[ 1, 4, 9, 16, 25, 36, 49, 64, 81, 100 ]\nEm GAP uma matriz é lista de listas (que são as linhas da matriz). As entradas de matrizes são tipicamente números ou, mais geralmente, elementos de um anel ou corpo. As matrizes podem ser somadas e multiplicadas exatamente como números.\ngap&gt; List( [1..10], x-&gt;x^2 );\n[ 1, 4, 9, 16, 25, 36, 49, 64, 81, 100 ]\ngap&gt; m1 := [[1,2,0],[0,-2,3]];\n[ [ 1, 2, 0 ], [ 0, -2, 3 ] ]\ngap&gt; Display( m1 );\n[ [   1,   2,   0 ],\n  [   0,  -2,   3 ] ]\ngap&gt; m2 := [[1,-1],[0,3],[4,1/2]];\n[ [ 1, -1 ], [ 0, 3 ], [ 4, 1/2 ] ]\ngap&gt; Display( m2 );\n[ [    1,   -1 ],\n  [    0,    3 ],\n  [    4,  1/2 ] ]\ngap&gt; m1*m2;\n[ [ 1, 5 ], [ 12, -9/2 ] ]\ngap&gt; Display( last );\n[ [     1,     5 ],\n  [    12,  -9/2 ] ]\ngap&gt; m2*m1;\n[ [ 1, 4, -3 ], [ 0, -6, 9 ], [ 4, 7, 3/2 ] ]\ngap&gt; Display( last );\n[ [    1,    4,   -3 ],\n  [    0,   -6,    9 ],\n  [    4,    7,  3/2 ] ]\nOutro objeto fundamento quando trabalhamos com grupos finitos é a permutação. Permutações em GAP podem ser definidas como produto de cíclos disjuntos mas também usando uma lista.\ngap&gt; p1 := (1,2,3)(4,5,6);\n(1,2,3)(4,5,6)\ngap&gt; p1^2;\n(1,3,2)(4,6,5)\ngap&gt; p2 := PermList( [1,5,4,3,2] );\n(2,5)(3,4)\ngap&gt; p1*p2;\n(1,5,6,3)(2,4)\ngap&gt; p2*p1;\n(1,2,6,4)(3,5)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Aritmética básica</span>"
    ]
  },
  {
    "objectID": "ling.html",
    "href": "ling.html",
    "title": "3  A linguagem de programação",
    "section": "",
    "text": "3.0.1 Expressões if-then\nA expressão if-then está usada quando queremos executar instruções de acordo com alguma condição que pode ser verdadeira ou falsa. Considere o seguinte exemplo:\ngap&gt; a := 3;                # seja a inicialmente 3\n3\ngap&gt; if a mod 2 = 0 then    # se a for par, dividimos a por 2\n&gt; b := a/2;\n&gt; fi;\ngap&gt; a;                     # valor de a continua 3\n3\ngap&gt; if a mod 2 = 1 then    # se a for ímpar, multiplicamos a por 3 e somamos 1\n&gt; a := 3*a+1;\n&gt; fi;\ngap&gt; a;                     # o valor de a mudou\n10\nExpressões mais complicadas podem ser montadas usando as palavras chaves else e elif.\ngap&gt; a := 3;\n3\ngap&gt; if a mod 2 = 0 then \n&gt; a := a/2;\n&gt; else\n&gt; a := 3*a+1;\n&gt; fi;\ngap&gt; a;\n10\ngap&gt; a := 8;\n8\ngap&gt; if a mod 2 = 0 then\n&gt; a := a/2;\n&gt; else\n&gt; a := 3*a+1;\n&gt; fi;\ngap&gt; a;\n4\n\n\n3.0.2 Laço for\n\n\n3.0.3 Laço while\n\n\n3.0.4 Laço repeat",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A linguagem de programação</span>"
    ]
  },
  {
    "objectID": "estrut.html",
    "href": "estrut.html",
    "title": "4  Estruturas algébricas",
    "section": "",
    "text": "4.0.1 Os primeiros passos com grupos\nGAP permite várias formas de definir grupos. O sistema já vem com algumas classes de grupos pré-definidas.\ngap&gt; G1 := SL( 3, GF(5));\nSL(3,5)\ngap&gt; G1 := SL( 3, 5);\nSL(3,5)\ngap&gt; G1 := SL( 3, 5 );\nSL(3,5)\ngap&gt; G1 := GL( 3, 5 );\nGL(3,5)\ngap&gt; G2 := SL( 3, 5 );\nSL(3,5)\ngap&gt; Order( G1 );\n1488000\ngap&gt; Order( G2 );\n372000\ngap&gt; S6 := SymmetricGroup( 6 );\nSym( [ 1 .. 6 ] )\ngap&gt; A6 := AlternatingGroup( 6 );\nAlt( [ 1 .. 6 ] )\ngap&gt; IsSubgroup( G1, G2 );\ntrue\ngap&gt; IsSubgroup( S6, A6 );\ntrue\ngap&gt; IsNormal( S6, A6 );\ntrue\ngap&gt; IsNormal( G1, G2 );\ntrue\nPode também definir grupo por geradores. Os geradores podem ser objetos multiplicáveis, tipicamente usamos matrizes e permutações. Primeiro, consideremos alguns exemplos com permutações.\ngap&gt; G := Group( (1,2), (1,2,3,4,5));\nGroup([ (1,2), (1,2,3,4,5) ])\ngap&gt; Size( G );\n120\ngap&gt; G = SymmetricGroup( 5 );\ntrue\ngap&gt; A := Group( (1,2,3),(3,4,5));\nGroup([ (1,2,3), (3,4,5) ])\ngap&gt; Size( A );\n60\ngap&gt; A = AlternatingGroup( 5 );\ntrue\ngap&gt; A = SymmetricGroup( 5 );\nfalse\nO grupo dihedral \\(D_5\\) de ordem \\(10\\) pode ser construído da forma seguinte.\ngap&gt; D := Group( (1,2,3,4,5),(2,4)(3,5));\nGroup([ (1,2,3,4,5), (2,4)(3,5) ])\ngap&gt; Size( D );\n60\ngap&gt; D := Group( (1,2,3,4,5),(2,5)(3,4));\nGroup([ (1,2,3,4,5), (2,5)(3,4) ])\ngap&gt; Size( D );\n10\ngap&gt; Elements( D );\n[ (), (2,5)(3,4), (1,2)(3,5), (1,2,3,4,5), (1,3)(4,5), (1,3,5,2,4), (1,4)(2,3), (1,4,2,5,3), (1,5,4,3,2), (1,5)(2,4) ]\ngap&gt; IsSubgroup( AlternatingGroup( 5 ), D );\ntrue\ngap&gt; IsNormal( AlternatingGroup( 5 ), D );\nfalse\nPara ver um grupo gerado por matrizes, considere o grupo de Heisenberg sobre \\(\\mathbb F_5\\).\ngap&gt; F := GF( 5 );\nGF(5)\ngap&gt; e := One( F );\nZ(5)^0\ngap&gt; mx := [[1,1,0],[0,1,0],[0,0,1]]*e;\n[ [ Z(5)^0, Z(5)^0, 0*Z(5) ], [ 0*Z(5), Z(5)^0, 0*Z(5) ], [ 0*Z(5), 0*Z(5), Z(5)^0 ] ]\ngap&gt; Display( mx );\n 1 1 .\n . 1 .\n . . 1\ngap&gt; my := [[1,0,0],[0,1,1],[0,0,1]]*e;\n[ [ Z(5)^0, 0*Z(5), 0*Z(5) ], [ 0*Z(5), Z(5)^0, Z(5)^0 ], [ 0*Z(5), 0*Z(5), Z(5)^0 ] ]\ngap&gt; Display( my );\n 1 . .\n . 1 1\n . . 1\ngap&gt; H := Group( mx, my );\nGroup([ [ [ Z(5)^0, Z(5)^0, 0*Z(5) ], [ 0*Z(5), Z(5)^0, 0*Z(5) ], [ 0*Z(5), 0*Z(5), Z(5)^0 ] ], \n  [ [ Z(5)^0, 0*Z(5), 0*Z(5) ], [ 0*Z(5), Z(5)^0, Z(5)^0 ], [ 0*Z(5), 0*Z(5), Z(5)^0 ] ] ])\ngap&gt; Size( H );\n125\ngap&gt; Comm( mx, my );\n[ [ Z(5)^0, 0*Z(5), Z(5)^0 ], [ 0*Z(5), Z(5)^0, 0*Z(5) ], [ 0*Z(5), 0*Z(5), Z(5)^0 ] ]\ngap&gt; Display( last );\n 1 . 1\n . 1 .\n . . 1\ngap&gt; IsSubgroup( SL( 3, 5 ), H );\ntrue\ngap&gt; IsNormal( SL( 3, 5 ), H );\nfalse\nVbRU_8/+kzP9Ek",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Estruturas algébricas</span>"
    ]
  },
  {
    "objectID": "collatz.html",
    "href": "collatz.html",
    "title": "5  A conjetura de Collatz",
    "section": "",
    "text": "5.1 Projeto 1: A Conjetura de Collatz",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A conjetura de Collatz</span>"
    ]
  },
  {
    "objectID": "collatz.html#projeto-1-a-conjetura-de-collatz",
    "href": "collatz.html#projeto-1-a-conjetura-de-collatz",
    "title": "5  A conjetura de Collatz",
    "section": "",
    "text": "\\(\\newcommand{\\N}{\\mathbb N}\\)\n\nConsidere a seguinte função \\(f:\\N\\to \\N\\): \\[\n    f(n)=\\left\\{\\begin{array}{cc} n/2 & \\mbox{se $n$ for par;}\\\\\n    3n+1 & \\mbox{se $n$ for ímpar.}\\end{array}\\right.\n\\] A Conjetura de Collatz afirma que para todo \\(n\\in\\N\\), existe um número \\(k\\) tal que aplicando a função \\(f\\) \\(k\\) vezes em \\(n\\), o resultado vai ser igual a \\(1\\). Em outras, palavras, \\(f^k(n)=1\\).\n\n\n5.1.1 Tarefa 1\n\nEscreva uma função collatz( n ) que toma \\(n\\) como input e devolve \\(f(n)\\). Faça testes da sua função com vários números.\n\n\nPrecisa testar se o input é par ou ímpar e para isso pode usar a operação mod (manual).\ngap&gt; 3 mod 2;\n1\ngap&gt; 6 mod 2;\n0\nAlém disso, a sua função precisará usar a expressão if (manual).\n\n\nA sua função deve comportar-se de acordo com os seguintes exemplos:\ngap&gt; collatz( 15 );\n46\ngap&gt; collatz( 14 );\n7\ngap&gt; collatz( 5 );\n16\n\n\n\n5.1.2 Tarefa 2\n\nEscreva uma função nr_steps( n ) que vai calcular o número de vezes a função \\(f\\) precisa ser aplicado em \\(n\\) para obter o número \\(1\\). Em outras palavras, nr_steps( n ) deve devolver o menor número \\(k\\) tal que \\(f^k(n)=1\\).\n\n\nVocê usará a função a função collatz( n ) na tarefa anterior em um laço while (manual) ou repeat (manual).\n\n\nA sua função precisa devolver input de acordo com os seguintes exemplos.\ngap&gt; nr_steps( 1 );\n0\ngap&gt; nr_steps( 3 );\n7\ngap&gt; nr_steps( 14 );\n17\ngap&gt; nr_steps( 32 );\n5\n\n\n\n5.1.3 Tarefa 3\n\nEscreva uma função max_nr_steps( n ) para determinar o número \\(k\\in\\{1,\\ldots,n\\}\\) tal que nr_steps( k ) é maior possível.\n\n\nPode usar a função nr_steps( k ) escrita na tarefa anterior em um laço for (manual) que roda na lista [1..n].\n\n\nO comportamento da sua função seguirá os seguintes exemplos:\ngap&gt; max_nr_steps( 1000 );\n[ 871, 178 ]\ngap&gt; max_nr_steps( 10000 );\n[ 6171, 261 ]\ngap&gt; max_nr_steps( 100000 );\n[ 77031, 350 ]\n\n\n\n5.1.4 Tarefa 4\n\nCalcular nr_steps( k ) separadamente para todo \\(k\\in \\{1,\\ldots,n\\}\\) faz muita computação redundante. Por exemplo, calculando max_nr_steps( 6 ) deste jeito, fazemos as seguintes contas\n1 → 1 \n2 → 1\n3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 \n4 → 2 → 1 \n5 → 16 → 8 → 4 → 2 → 1\n6 → 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1\nOu seja, a computação nr_steps( 6 ) deve realizar que nr_steps( 3 ) já foi calculado e simplificar a conta por computar que nr_steps( 6 ) = nr_steps( 3 ) + 1. Escreva uma versão da função max_nr_steps( n ) utilizando as computações anteriores e compare o tempo de execução das duas versões.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A conjetura de Collatz</span>"
    ]
  }
]