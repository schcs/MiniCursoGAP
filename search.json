[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Álgebra Computacional com GAP",
    "section": "",
    "text": "1 MiniCursoGAP\nEste material foi preparado para o minicurso de Álgebra Computacional com GAP que foi realizado na XXVII Escola de Álgebra em São Paulo (2024). Durante as 5 sessões do minicurso, os participantes trabalham em vá\n\nRodar o sistema, criar, salvar e carregar arquivos\nAritmética básica, variáveis, funções\nListas, matrizes, permutações\nO primeiro encontro com grupos\nA linguagem de programação\nA Conjetura de Collatz\nNúmeros perfeitos, abundantes, e sequências alíquotas\nCriptografia RSA\nConceitos básicos com grupos\nUma exploração dos centralizadores\nHomomorfismos, automorfismos, etc, de grupos\nComutadores de grupos\nGrupos livres, homomorfismos, Exploração do cubo mágico\nGrupos de permutação\nGrupos de matrizes\nCarateres de um grupo e a ordem generalizada\nÁlgebras de Lie\nÁlgebras associativas\nÁlgebra comutativa\nBases de Grobner\nTeoria de Galois\nTeoria de grafos",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>MiniCursoGAP</span>"
    ]
  },
  {
    "objectID": "arith.html",
    "href": "arith.html",
    "title": "2  Aritmética básica",
    "section": "",
    "text": "2.1 Operações aritméticas\nNote a diferença entre trabalhar com valores exatos (como por exemplo 1/3) e valores aproximados (por exemplo 1.0/3).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Aritmética básica</span>"
    ]
  },
  {
    "objectID": "arith.html#operações-aritméticas",
    "href": "arith.html#operações-aritméticas",
    "title": "2  Aritmética básica",
    "section": "",
    "text": "As operações mais comuns em GAP são + (adição), - (subtração), * (multiplicação), / (divisão), mod, (resto) ^ (exponenciação). Experimente com os seguintes exemplos.\ngap&gt; 2+3;\n5\ngap&gt; 2/4;\n1/2\ngap&gt; (2+3)*(1/2);\n5/2\ngap&gt; 2^3*3;\n24\ngap&gt; 2^-2*3;\n3/4\ngap&gt; 2.0;\n2.\ngap&gt; 2.01+3.11;\n5.12\ngap&gt; 1/3;\n1/3\ngap&gt; 1.0/3;\n0.333333",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Aritmética básica</span>"
    ]
  },
  {
    "objectID": "arith.html#operações-lógicas-booleanas",
    "href": "arith.html#operações-lógicas-booleanas",
    "title": "2  Aritmética básica",
    "section": "2.2 Operações lógicas (booleanas)",
    "text": "2.2 Operações lógicas (booleanas)\nPara comparar valores, usamos a operação = cujo valor é um valor lógico ou seja true ou false. As operações com valores lógicos são not, and e or.\ngap&gt; 2 + 3 = 5;\ntrue\ngap&gt; 2 + 3 = 5 or 2 + 3 = 6;\ntrue\ngap&gt; 2 + 3 = 5 and 2 + 3 = 6;\nfalse\ngap&gt; 2 + 3 = 5 and  not 2 + 3 = 6;\ntrue",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Aritmética básica</span>"
    ]
  },
  {
    "objectID": "arith.html#corpos-finitos",
    "href": "arith.html#corpos-finitos",
    "title": "2  Aritmética básica",
    "section": "2.3 Corpos finitos",
    "text": "2.3 Corpos finitos\nQuando trabalhamos com estruturas algébricas, precisamos trabalhar com corpos além do corpo \\(\\mathbb Q\\). Aqui em baixo veremos alguns exemplos para aritmética com corpos finitos. Sabemos que o grupo multiplicativo de um corpo finito é cíclico. Isso quer dizer que para todo corpo finito \\(\\mathbb F\\), existe um elemento \\(z\\in \\mathbb F\\) tal que os elementos não nulos de \\(\\mathbb F\\) são as potências de \\(z\\); ou seja, \\[\n\\mathbb F=\\{0\\}\\cup \\{z^0,z^1,\\ldots,z^{q-2}\\}\n\\] onde \\(q=|\\mathbb F|\\). Para uma potência de primo q, função Z( q ) devolve um gerador explícito do corpo finito GF( q ) (Galois Field). Os elementos não nulos de GF( q ) são representados como potências de Z( q ). Considere os seguintes exemplos.\ngap&gt; F := GF(11);\nGF(11)\ngap&gt; e := One( F );\nZ(11)^0\ngap&gt; z := Zero( F );\n0*Z(11)\ngap&gt; p := PrimitiveElement( F );\nZ(11)\ngap&gt; e+p;\nZ(11)^8\ngap&gt; e+p^2;\nZ(11)^4\ngap&gt; IntFFE( e+p^2 );\n5",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Aritmética básica</span>"
    ]
  },
  {
    "objectID": "arith.html#variáveis",
    "href": "arith.html#variáveis",
    "title": "2  Aritmética básica",
    "section": "2.4 Variáveis",
    "text": "2.4 Variáveis\nAs variáveis guardam valores. Uma variável é um string de letras, números e alguns carateres especiais. Aqui é um exemplo simples.\ngap&gt; a := 2;\n2\ngap&gt; a3 := 3;\n3\ngap&gt; a_5 := 5;\n5\ngap&gt; a := 2; \n2\ngap&gt; b := 3;\n3\ngap&gt; a + b; a*b;\n5\n6\nVariávies podem conter valores mais complexos, como nos seguintes exemplos.\ngap&gt; s1 := \"Hello\";\n\"Hello\"\ngap&gt; s2 := \" World!\";\n\" World!\"\ngap&gt; Concatenation( s1, s2 );\n\"Hello World!\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Aritmética básica</span>"
    ]
  },
  {
    "objectID": "arith.html#funções",
    "href": "arith.html#funções",
    "title": "2  Aritmética básica",
    "section": "2.5 Funções",
    "text": "2.5 Funções\nFunções em GAP podem ser usadas para realizar computações que queremos fazer várias vezes com diferentes objetos. Por exemplo a função que, dado x computa 3*x+1 pode ser definida de duas maneiras diferentes.\ngap&gt; f1 := function( x )\n&gt; return 3*x+1;\n&gt; end;\nfunction( x ) ... end\ngap&gt; f1( 5 );\n16\ngap&gt; f2 := x -&gt; 3*x + 1;\nfunction( x ) ... end\ngap&gt; f2( -2 );\n-5\ngap&gt; f1 = f2;\nfalse\n# As funções f1 e f2 fazem a mesma coisa, mas são objetos distintos\nNos exemplos anteriores, a função não precisa de variáveis adicionais para executar sua tarefa. Isso pode acontecer com funções simples, mas uma função mais complicada pode precisar introduzir as suas próprias variáveis, chamadas de variáveis locais. Considere a seguinte implementação do exemplo em cima.\ngap&gt; f3 := function( x )\n&gt; local y;\n&gt; y := 3*x;\n&gt; return y+1;\n&gt; end;\nfunction( x ) ... end\ngap&gt; f3(4);\n13\ngap&gt; y;\nError, Variable: 'y' must have a value\nnot in any function at *stdin*:44\nAs últimas linhas do exemplo anterior mostram que o variável y não está visível fora da função. Isso permite que variáveis com o mesmo nome sejam usadas em várias funções sem que sejam confundidas. O mesmo também impede que a varíavel local y definida dentro da função f3 seja confundida com uma possível variável global também chamada de y. O seguinte código mostra que o nome y tem significado diferente dentro e fora da função.\ngap&gt; f3 := function( x )\n&gt; local y;\n&gt; y := 3*x;\n&gt; Print( \"O valor de y é \", y, \"\\n\" );\n&gt; return y+1;\n&gt; end;\nfunction( x ) ... end\ngap&gt; y := -5;\n-5\ngap&gt; f3(10);\nO valor de y é 30\n31\ngap&gt; y;\n-5",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Aritmética básica</span>"
    ]
  },
  {
    "objectID": "ling.html",
    "href": "ling.html",
    "title": "3  A linguagem de programação",
    "section": "",
    "text": "3.1 Expressões if-then-else\nA expressão if-then está usada quando queremos executar instruções de acordo com alguma condição que pode ser verdadeira ou falsa. Considere o seguinte exemplo:\nExpressões mais complicadas podem ser montadas usando as palavras chaves else e elif.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A linguagem de programação</span>"
    ]
  },
  {
    "objectID": "ling.html#expressões-if-then-else",
    "href": "ling.html#expressões-if-then-else",
    "title": "3  A linguagem de programação",
    "section": "",
    "text": "gap&gt; a := 3;                # seja a inicialmente 3\n3\ngap&gt; if a mod 2 = 0 then    # se a for par, dividimos a por 2\n&gt; b := a/2;\n&gt; fi;\ngap&gt; a;                     # valor de a continua 3\n3\ngap&gt; if a mod 2 = 1 then    # se a for ímpar, multiplicamos a por 3 e somamos 1\n&gt; a := 3*a+1;\n&gt; fi;\ngap&gt; a;                     # o valor de a mudou\n10\n\ngap&gt; a := 3;\n3\ngap&gt; if a mod 2 = 0 then \n&gt; a := a/2;\n&gt; else\n&gt; a := 3*a+1;\n&gt; fi;\ngap&gt; a;\n10\ngap&gt; a := 8;\n8\ngap&gt; if a mod 2 = 0 then\n&gt; a := a/2;\n&gt; else\n&gt; a := 3*a+1;\n&gt; fi;\ngap&gt; a;\n4",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A linguagem de programação</span>"
    ]
  },
  {
    "objectID": "ling.html#laço-for",
    "href": "ling.html#laço-for",
    "title": "3  A linguagem de programação",
    "section": "3.2 Laço for",
    "text": "3.2 Laço for\nUsamos for quando queremos executar a mesma peça de código várias vezes. Por exemplo, queremos calcular o quadrado dos números entre 1 e 10.\ngap&gt; for i in [1..10] do\n&gt; Print( \"O quadrado de \", i, \" é \", i^2, \"\\n\" );\n&gt; od;\nO quadrado de 1 é 1\nO quadrado de 2 é 4\nO quadrado de 3 é 9\nO quadrado de 4 é 16\nO quadrado de 5 é 25\nO quadrado de 6 é 36\nO quadrado de 7 é 49\nO quadrado de 8 é 64\nO quadrado de 9 é 81\nO quadrado de 10 é 100\ngap&gt; \nObservamos os seguintes regras importantes:\n\na palavra chave for é seguida por uma variável, neste caso i;\ndepois temos a palavra in seguida por uma lista;\ndepois da lista temos a palavra do;\no laço está fechado pela palavra od (do invertido).\n\nO ciclo executa o código entre as palavras do e od para todo valor i na lista que aparece depois da palavra in.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A linguagem de programação</span>"
    ]
  },
  {
    "objectID": "ling.html#laço-while",
    "href": "ling.html#laço-while",
    "title": "3  A linguagem de programação",
    "section": "3.3 Laço while",
    "text": "3.3 Laço while\nUma outra maneira de criar um laço é usar a construção com while. Considere o seguinte exemplo.\ngap&gt; while i &lt;= 10 do \n&gt; Print( \"O quadrado de \", i, \" é \", i^2, \"\\n\" );\n&gt; i := i + 1;\n&gt; od;\nO quadrado de 0 é 0\nO quadrado de 1 é 1\nO quadrado de 2 é 4\nO quadrado de 3 é 9\nO quadrado de 4 é 16\nO quadrado de 5 é 25\nO quadrado de 6 é 36\nO quadrado de 7 é 49\nO quadrado de 8 é 64\nO quadrado de 9 é 81\nO quadrado de 10 é 100\nAs regras de construir este tipo de laço são as seguintes:\n\na palavra while (enquanto) está seguida por uma condição lógica (booleana) e depois pela palavra do;\no laço está fechado pela palavra od;\na peça de código está executado entre as palavras do e od enquanto (while) a condição está verdadeira.\n\nNote que no laço while o valor da variável i precisa ser incrementado manualmente.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A linguagem de programação</span>"
    ]
  },
  {
    "objectID": "ling.html#laço-repeat",
    "href": "ling.html#laço-repeat",
    "title": "3  A linguagem de programação",
    "section": "3.4 Laço repeat",
    "text": "3.4 Laço repeat\nO terceiro tipo de laço pode ser construída com a palavra repeat. Considere o seguinte exemplo:\ngap&gt; i := 0;\n0\ngap&gt; repeat\n&gt; Print( \"O quadrado de \", i, \" é \", i^2, \"\\n\" );\n&gt; i := i + 1;\n&gt; until i = 10;\nO quadrado de 0 é 0\nO quadrado de 1 é 1\nO quadrado de 2 é 4\nO quadrado de 3 é 9\nO quadrado de 4 é 16\nO quadrado de 5 é 25\nO quadrado de 6 é 36\nO quadrado de 7 é 49\nO quadrado de 8 é 64\nO quadrado de 9 é 81\nObservamos que\n\nO laço está iniciado pela palavra repeat;\nna última linha, temos a palavra until seguida por uma condição lógica;\no sistema termina a execução do laço assim que a condição depois de repeat vira verdadeira.\n\nA diferença entre os laços construídos por while e repeat é que no caso de while a decisão está feita antes da execução do código, enquanto no caso de repeata mesma decisão está feita depois da execução. Em particular, o laço repeat sempre será executado pelo menos uma vez. Considere o seguinte código e explique o comportamento.\ngap&gt; i := 11;\n11\ngap&gt; while i &lt;= 10 do\n&gt; Print( \"O quadrado de \", i, \" é \", i^2, \"\\n\" );\n&gt; i := i + 1;\n&gt; od;\n\ngap&gt; i := 11;\n11\ngap&gt; repeat\n&gt; Print( \"O quadrado de \", i, \" é \", i^2, \"\\n\" );\n&gt; i := 11;\n&gt; until i &gt;= 10;\nO quadrado de 11 é 121",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>A linguagem de programação</span>"
    ]
  },
  {
    "objectID": "list_mat_perm.html",
    "href": "list_mat_perm.html",
    "title": "4  Listas, matrizes e permutações",
    "section": "",
    "text": "4.1 Listas\nListas são importantes em GAP. Listas contém uma sequência de objetos. Os objetos nas listas podem ser números, carateres, ou até objetos complexos, tais como grupos, subgrupos de um grupo, etc. Os seguintes exemplos mostram a criação de listas e as operações básicas com listas.\nListas podem ser criadas usando outras listas. Por exemplo, criamos a list dos quadrados dos primeiros 10 números naturais:",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Listas, matrizes e permutações</span>"
    ]
  },
  {
    "objectID": "list_mat_perm.html#listas",
    "href": "list_mat_perm.html#listas",
    "title": "4  Listas, matrizes e permutações",
    "section": "",
    "text": "gap&gt; L1 := [1,3,5,7,9,10,8,6,4,2,0];\n[ 1, 3, 5, 7, 9, 10, 8, 6, 4, 2, 0 ]\ngap&gt; L2 := [\"a\",\"b\",\"c\",\"z\",\"x\",\"y\"];\n[ \"a\", \"b\", \"c\", \"z\", \"x\", \"y\" ]\ngap&gt; L1[3];\n5\ngap&gt; 10 in L1;\ntrue\ngap&gt; 10 in L2;\nfalse\ngap&gt; \"a\" in L2;\ntrue\ngap&gt; Union( L1, L2 );\n[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, \"a\", \"b\", \"c\", \"x\", \"y\", \"z\" ]\ngap&gt; Position( L1, 10 );\n6\ngap&gt; Position( L1, -1 );\nfail\ngap&gt; Intersection( L1, L2 );\n[  ]\ngap&gt; Filtered( L, x -&gt; x mod 2 = 0 );\nError, Variable: 'L' must have a value\nnot in any function at *stdin*:2\ngap&gt; Filtered( L1, x -&gt; x mod 2 = 0 );\n[ 10, 8, 6, 4, 2, 0 ]\ngap&gt; Filtered( L1, x -&gt; x mod 2 = 1 );\n[ 1, 3, 5, 7, 9 ]\ngap&gt; Filtered( L1, x -&gt; IsEvenInt( x ));\n[ 10, 8, 6, 4, 2, 0 ]\ngap&gt; Filtered( L1, x -&gt; IsOddInt( x ));\n[ 1, 3, 5, 7, 9 ]\ngap&gt; Filtered( L1, IsEvenInt );\n[ 10, 8, 6, 4, 2, 0 ]\ngap&gt; Filtered( L1, IsOddInt );\n[ 1, 3, 5, 7, 9 ]\ngap&gt; \n\ngap&gt; List( [1..10], x-&gt;x^2 );\n[ 1, 4, 9, 16, 25, 36, 49, 64, 81, 100 ]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Listas, matrizes e permutações</span>"
    ]
  },
  {
    "objectID": "list_mat_perm.html#matrizes",
    "href": "list_mat_perm.html#matrizes",
    "title": "4  Listas, matrizes e permutações",
    "section": "4.2 Matrizes",
    "text": "4.2 Matrizes\nEm GAP uma matriz é lista de listas (que são as linhas da matriz). As entradas de matrizes são tipicamente números ou, mais geralmente, elementos de um anel ou corpo. As matrizes podem ser somadas e multiplicadas exatamente como números.\ngap&gt; List( [1..10], x-&gt;x^2 );\n[ 1, 4, 9, 16, 25, 36, 49, 64, 81, 100 ]\ngap&gt; m1 := [[1,2,0],[0,-2,3]];\n[ [ 1, 2, 0 ], [ 0, -2, 3 ] ]\ngap&gt; Display( m1 );\n[ [   1,   2,   0 ],\n  [   0,  -2,   3 ] ]\ngap&gt; m2 := [[1,-1],[0,3],[4,1/2]];\n[ [ 1, -1 ], [ 0, 3 ], [ 4, 1/2 ] ]\ngap&gt; Display( m2 );\n[ [    1,   -1 ],\n  [    0,    3 ],\n  [    4,  1/2 ] ]\ngap&gt; m1*m2;\n[ [ 1, 5 ], [ 12, -9/2 ] ]\ngap&gt; Display( last );\n[ [     1,     5 ],\n  [    12,  -9/2 ] ]\ngap&gt; m2*m1;\n[ [ 1, 4, -3 ], [ 0, -6, 9 ], [ 4, 7, 3/2 ] ]\ngap&gt; Display( last );\n[ [    1,    4,   -3 ],\n  [    0,   -6,    9 ],\n  [    4,    7,  3/2 ] ]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Listas, matrizes e permutações</span>"
    ]
  },
  {
    "objectID": "list_mat_perm.html#permutações",
    "href": "list_mat_perm.html#permutações",
    "title": "4  Listas, matrizes e permutações",
    "section": "4.3 Permutações",
    "text": "4.3 Permutações\nOutro objeto fundamento quando trabalhamos com grupos finitos é a permutação. Permutações em GAP podem ser definidas como produto de cíclos disjuntos mas também usando uma lista.\ngap&gt; p1 := (1,2,3)(4,5,6);\n(1,2,3)(4,5,6)\ngap&gt; p1^2;\n(1,3,2)(4,6,5)\ngap&gt; p2 := PermList( [1,5,4,3,2] );\n(2,5)(3,4)\ngap&gt; p1*p2;\n(1,5,6,3)(2,4)\ngap&gt; p2*p1;\n(1,2,6,4)(3,5)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Listas, matrizes e permutações</span>"
    ]
  },
  {
    "objectID": "estrut.html",
    "href": "estrut.html",
    "title": "5  O primeiro encontro com grupos",
    "section": "",
    "text": "5.1 Grupos disponíveis na biblioteca\nGAP permite várias formas de definir grupos. O sistema já vem com algumas classes de grupos pré-definidas. Primeiro considere alguns exemplos usando os grupos GL e SL.\nOra, considere construções com SymmetricGroup e AlternatingGroup.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>O primeiro encontro com grupos</span>"
    ]
  },
  {
    "objectID": "estrut.html#grupos-disponíveis-na-biblioteca",
    "href": "estrut.html#grupos-disponíveis-na-biblioteca",
    "title": "5  O primeiro encontro com grupos",
    "section": "",
    "text": "gap&gt; G1 := SL( 3, GF(5));\nSL(3,5)\ngap&gt; G1 := SL( 3, 5);\nSL(3,5)\ngap&gt; G1 := SL( 3, 5 );\nSL(3,5)\ngap&gt; G1 := GL( 3, 5 );\nGL(3,5)\ngap&gt; G2 := SL( 3, 5 );\nSL(3,5)\ngap&gt; Order( G1 );\n1488000\ngap&gt; Order( G2 );\n372000\ngap&gt; IsSubgroup( G1, G2 );\ntrue\ngap&gt; IsNormal( G1, G2 );\ntrue\n\ngap&gt; S6 := SymmetricGroup( 6 );\nSym( [ 1 .. 6 ] )\ngap&gt; A6 := AlternatingGroup( 6 );\nAlt( [ 1 .. 6 ] )\ngap&gt; IsSubgroup( S6, A6 );\ntrue\ngap&gt; IsNormal( S6, A6 );\ntrue",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>O primeiro encontro com grupos</span>"
    ]
  },
  {
    "objectID": "estrut.html#grupos-gerados-por-permutações",
    "href": "estrut.html#grupos-gerados-por-permutações",
    "title": "5  O primeiro encontro com grupos",
    "section": "5.2 Grupos gerados por permutações",
    "text": "5.2 Grupos gerados por permutações\nPode também definir grupo por geradores. Os geradores podem ser objetos multiplicáveis, tipicamente usamos matrizes e permutações. Primeiro, consideremos alguns exemplos com permutações.\ngap&gt; G := Group( (1,2), (1,2,3,4,5));\nGroup([ (1,2), (1,2,3,4,5) ])\ngap&gt; Size( G );\n120\ngap&gt; G = SymmetricGroup( 5 );\ntrue\ngap&gt; A := Group( (1,2,3),(3,4,5));\nGroup([ (1,2,3), (3,4,5) ])\ngap&gt; Size( A );\n60\ngap&gt; A = AlternatingGroup( 5 );\ntrue\ngap&gt; A = SymmetricGroup( 5 );\nfalse\nO grupo dihedral \\(D_5\\) de ordem \\(10\\) pode ser construído da forma seguinte.\ngap&gt; D := Group( (1,2,3,4,5),(2,5)(3,4));\nGroup([ (1,2,3,4,5), (2,5)(3,4) ])\ngap&gt; Size( D );\n10\ngap&gt; Elements( D );\n[ (), (2,5)(3,4), (1,2)(3,5), (1,2,3,4,5), (1,3)(4,5), (1,3,5,2,4), (1,4)(2,3), (1,4,2,5,3), (1,5,4,3,2), (1,5)(2,4) ]\ngap&gt; IsSubgroup( AlternatingGroup( 5 ), D );\ntrue\ngap&gt; IsNormal( AlternatingGroup( 5 ), D );\nfalse",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>O primeiro encontro com grupos</span>"
    ]
  },
  {
    "objectID": "estrut.html#grupos-gerados-por-matrizes",
    "href": "estrut.html#grupos-gerados-por-matrizes",
    "title": "5  O primeiro encontro com grupos",
    "section": "5.3 Grupos gerados por matrizes",
    "text": "5.3 Grupos gerados por matrizes\nPode-se também definir grupos de matrizes usando geradores. Considere por exemplo as seguintes duas matrizes sobre GF( 5 ): \\[\nm_1 = \\begin{pmatrix} 2 & 0 \\\\ 0 & 1 \\end{pmatrix}\\quad \\mbox{e}\\quad m_2 = \\begin{pmatrix} 2 & 1 \\\\ 2 & 0 \\end{pmatrix}.\n\\] O grupo gerado por \\(m_1\\) e \\(m_2\\) pode ser construído em GAP usando as seguintes instruções.\ngap&gt; m1 := [[2,0],[0,1]]*Z(5)^0;\n[ [ Z(5), 0*Z(5) ], [ 0*Z(5), Z(5)^0 ] ]\ngap&gt; m2 := [[2,1],[2,0]]*Z(5)^0;\n[ [ Z(5), Z(5)^0 ], [ Z(5), 0*Z(5) ] ]\ngap&gt; G := Group( m1, m2 );\nGroup([ [ [ Z(5), 0*Z(5) ], [ 0*Z(5), Z(5)^0 ] ], \n  [ [ Z(5), Z(5)^0 ], [ Z(5), 0*Z(5) ] ] ])\ngap&gt; Order( G );\n480\ngap&gt; G = GL( 2, 5 );\ntrue",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>O primeiro encontro com grupos</span>"
    ]
  },
  {
    "objectID": "estrut.html#projeto-o-grupo-de-heisenberg",
    "href": "estrut.html#projeto-o-grupo-de-heisenberg",
    "title": "5  O primeiro encontro com grupos",
    "section": "5.4 Projeto: O grupo de Heisenberg",
    "text": "5.4 Projeto: O grupo de Heisenberg\nSobre um corpo \\(\\mathbb F\\), o grupo de Heisenberg é o grupo \\[\nH=\\left\\{\\begin{pmatrix} 1 & a & c \\\\ 0 & 1 & b \\\\ 0 & 0 & c\\end{pmatrix}\\mid a, b, c \\in\\mathbb F\\right\\}.\n\\]\nO seguinte resultado é fácil de verificar.\n\nSe \\(\\mathbb F\\) é um corpo finito de ordem \\(q\\), então \\(|H|=q^3\\).\n\n\nTarefa 1: Construa em GAP o grupo de Heisenberg sobre os corpos GF(2), GF(3), GF(5), GF( 9 ), GF( 25 ) como um grupo de matrizes dado por geradores. Calcule a ordem do grupo construido para verificar que tem o grupo certo.\nTarefa 2: Escreva uma função heisenberg_group( q ) que devolve o grupo de Heisenberg sobre GF( q ) dado input q. A sua função precisa seguir o seguinte exemplo.\ngap&gt; H := heisenberg_group( 5 );\nGroup(\n[ \n  [ [ Z(5)^0, Z(5)^0, 0*Z(5) ], [ 0*Z(5), Z(5)^0, 0*Z(5) ], \n      [ 0*Z(5), 0*Z(5), Z(5)^0 ] ], \n  [ [ Z(5)^0, 0*Z(5), 0*Z(5) ], [ 0*Z(5), Z(5)^0, Z(5)^0 ], \n      [ 0*Z(5), 0*Z(5), Z(5)^0 ] ] ])\ngap&gt; Order( H );\n125\ngap&gt; H := heisenberg_group( 7 );\nGroup(\n[ \n  [ [ Z(7)^0, Z(7)^0, 0*Z(7) ], [ 0*Z(7), Z(7)^0, 0*Z(7) ], \n      [ 0*Z(7), 0*Z(7), Z(7)^0 ] ], \n  [ [ Z(7)^0, 0*Z(7), 0*Z(7) ], [ 0*Z(7), Z(7)^0, Z(7)^0 ], \n      [ 0*Z(7), 0*Z(7), Z(7)^0 ] ] ])\ngap&gt; Order( H );\n343\ngap&gt; H := heisenberg_group( 3 );\n&lt;matrix group of size 729 with 4 generators&gt;\ngap&gt; Order( H );\n729\nTarefa 3: Investiga o grupo de Heisenberg usando a sua função construída na Tarefa 2. Calcule o seu centro, subgrupo derivado, os termos da série derivada, série central superior, e série central inferior.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>O primeiro encontro com grupos</span>"
    ]
  },
  {
    "objectID": "collatz.html",
    "href": "collatz.html",
    "title": "6  A conjetura de Collatz",
    "section": "",
    "text": "6.1 Projeto 1: A Conjetura de Collatz",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>A conjetura de Collatz</span>"
    ]
  },
  {
    "objectID": "collatz.html#projeto-1-a-conjetura-de-collatz",
    "href": "collatz.html#projeto-1-a-conjetura-de-collatz",
    "title": "6  A conjetura de Collatz",
    "section": "",
    "text": "\\(\\newcommand{\\N}{\\mathbb N}\\)\n\nConsidere a seguinte função \\(f:\\N\\to \\N\\): \\[\n    f(n)=\\left\\{\\begin{array}{cc} n/2 & \\mbox{se $n$ for par;}\\\\\n    3n+1 & \\mbox{se $n$ for ímpar.}\\end{array}\\right.\n\\] A Conjetura de Collatz afirma que para todo \\(n\\in\\N\\), existe um número \\(k\\) tal que aplicando a função \\(f\\) \\(k\\) vezes em \\(n\\), o resultado vai ser igual a \\(1\\). Em outras, palavras, \\(f^k(n)=1\\).\n\n\n6.1.1 Tarefa 1\n\nEscreva uma função collatz( n ) que toma \\(n\\) como input e devolve \\(f(n)\\). Faça testes da sua função com vários números.\n\n\nPrecisa testar se o input é par ou ímpar e para isso pode usar a operação mod (manual).\ngap&gt; 3 mod 2;\n1\ngap&gt; 6 mod 2;\n0\nAlém disso, a sua função precisará usar a expressão if (manual).\n\n\nA sua função deve comportar-se de acordo com os seguintes exemplos:\ngap&gt; collatz( 15 );\n46\ngap&gt; collatz( 14 );\n7\ngap&gt; collatz( 5 );\n16\n\n\n\n6.1.2 Tarefa 2\n\nEscreva uma função nr_steps( n ) que vai calcular o número de vezes a função \\(f\\) precisa ser aplicado em \\(n\\) para obter o número \\(1\\). Em outras palavras, nr_steps( n ) deve devolver o menor número \\(k\\) tal que \\(f^k(n)=1\\).\n\n\nVocê usará a função collatz( n ) na tarefa anterior em um laço while (manual) ou repeat (manual).\n\n\nA sua função precisa devolver input de acordo com os seguintes exemplos.\ngap&gt; nr_steps( 1 );\n0\ngap&gt; nr_steps( 3 );\n7\ngap&gt; nr_steps( 14 );\n17\ngap&gt; nr_steps( 32 );\n5\n\n\n\n6.1.3 Tarefa 3\n\nEscreva uma função max_nr_steps( n ) para determinar o número \\(k\\in\\{1,\\ldots,n\\}\\) tal que nr_steps( k ) é maior possível.\n\n\nPode usar a função nr_steps( k ) escrita na tarefa anterior em um laço for (manual) que roda na lista [1..n].\n\n\nO comportamento da sua função seguirá os seguintes exemplos:\ngap&gt; max_nr_steps( 1000 );\n[ 871, 178 ]\ngap&gt; max_nr_steps( 10000 );\n[ 6171, 261 ]\ngap&gt; max_nr_steps( 100000 );\n[ 77031, 350 ]\n\n\n\n6.1.4 Tarefa 4\n\nCalcular nr_steps( k ) separadamente para todo \\(k\\in \\{1,\\ldots,n\\}\\) faz muita computação redundante. Por exemplo, calculando max_nr_steps( 6 ) deste jeito, fazemos as seguintes contas\n1 → 1 \n2 → 1\n3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 \n4 → 2 → 1 \n5 → 16 → 8 → 4 → 2 → 1\n6 → 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1\nOu seja, a computação nr_steps( 6 ) deve realizar que nr_steps( 3 ) já foi calculado e simplificar a conta por computar que nr_steps( 6 ) = nr_steps( 3 ) + 1. Escreva uma versão da função max_nr_steps( n ) utilizando as computações anteriores e compare o tempo de execução das duas versões.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>A conjetura de Collatz</span>"
    ]
  },
  {
    "objectID": "aliquot.html",
    "href": "aliquot.html",
    "title": "7  Projeto: A sequência alíquota",
    "section": "",
    "text": "7.1 Tarefa 1\nEscreva uma função sum_divisors( n ) em GAP que dado um numero n devolve \\(\\sigma(n)\\). Pode usar a função DivisorsInt. A sua função deve se comportar como no seguinte exemplo.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Projeto: A sequência alíquota</span>"
    ]
  },
  {
    "objectID": "aliquot.html#tarefa-1",
    "href": "aliquot.html#tarefa-1",
    "title": "7  Projeto: A sequência alíquota",
    "section": "",
    "text": "gap&gt; sum_divisors( 8 );\n7\ngap&gt; sum_divisors( 9 );\n4\ngap&gt; sum_divisors( 11 );\n1",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Projeto: A sequência alíquota</span>"
    ]
  },
  {
    "objectID": "aliquot.html#tarefa-2",
    "href": "aliquot.html#tarefa-2",
    "title": "7  Projeto: A sequência alíquota",
    "section": "7.2 Tarefa 2",
    "text": "7.2 Tarefa 2\nUm número \\(n\\) chama-se perfeito se \\(\\sigma(n)=n\\).\n\nEscreva uma função is_perfect( n ) que devolva true se n é perfeito e false se n não é perfeito.\n\ngap&gt; is_perfect( 6 );\ntrue\ngap&gt; is_perfect( 20 );\nfalse\ngap&gt; is_perfect( 28 );\ntrue\n\nAche todos os números perfeitos entre 1 e 1000000.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Projeto: A sequência alíquota</span>"
    ]
  },
  {
    "objectID": "aliquot.html#tarefa-3",
    "href": "aliquot.html#tarefa-3",
    "title": "7  Projeto: A sequência alíquota",
    "section": "7.3 Tarefa 3",
    "text": "7.3 Tarefa 3\nUm número \\(n\\) chama-se abundante, se \\(\\sigma(n)&gt;n\\). Ache todos os número abundantes entre 1 e 1000.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Projeto: A sequência alíquota</span>"
    ]
  },
  {
    "objectID": "aliquot.html#tarefa-4",
    "href": "aliquot.html#tarefa-4",
    "title": "7  Projeto: A sequência alíquota",
    "section": "7.4 Tarefa 4",
    "text": "7.4 Tarefa 4\nDois números \\(n\\) e \\(m\\) são chamados de amigáveis se \\(\\sigma(n)=m\\) e \\(\\sigma(m)=n\\).\n\nEscreva uma função is_friendly( n ) que verifica se um número n é membro de um par amigável. A função deve devolver o par de n caso sim, e 0 caso não.\n\ngap&gt; is_friendly( 6 );\n6\ngap&gt; is_friendly( 220 );\n284\ngap&gt; is_friendly( 284 );\n220\ngap&gt; is_friendly( 200 );\n0\n\nAche todos os pares amigáveis de números entre 1 e 1000000.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Projeto: A sequência alíquota</span>"
    ]
  },
  {
    "objectID": "aliquot.html#tarefa-5",
    "href": "aliquot.html#tarefa-5",
    "title": "7  Projeto: A sequência alíquota",
    "section": "7.5 Tarefa 5",
    "text": "7.5 Tarefa 5\nSeja \\(a_0\\in\\mathbb N\\) arbitrário. Defina a sequência que começa por \\(a_0\\) e para \\(i\\geq 1\\), \\(a_i=\\sigma(a_{i-1})\\). Por exemplo, se \\(a_0=8\\), então \\[\na_0=8,\\quad a_1=\\sigma(8)=7,\\quad a_2=\\sigma(7)=1, a_3=\\sigma(1)=0, \\quad a_4=\\sigma(0)=0.\n\\] Este tipo de sequência chama-se sequência alíquota (aliquot sequence).\n\nEscreva uma função aliquot_sequence( a0, k ) que, dado a0 e um número k, devolve os primeiros k termos da sequência alíquota que inicia-se com a0.\n\ngap&gt; aliquot_sequence( 8, 4 );\n[ 8, 7, 1, 0 ]\ngap&gt; aliquot_sequence( 24, 6 );\n[ 24, 36, 55, 17, 1, 0 ]\ngap&gt; aliquot_sequence( 30, 15 );\n[ 30, 42, 54, 66, 78, 90, 144, 259, 45, 33, 15, 9, 4, 3, 1 ]\n\nModifique a sua função em tal forma que a execução termina assim que a sequẽncia vira periódica.\n\ngap&gt; aliquot_sequence_until_repeat( 21 );\n[ 21, 11, 1, 0, 0 ]\ngap&gt; aliquot_sequence_until_repeat( 42 );\n[ 42, 54, 66, 78, 90, 144, 259, 45, 33, 15, 9, 4, 3, 1, 0, 0 ]\ngap&gt; aliquot_sequence_until_repeat( 34 );\n[ 34, 20, 22, 14, 10, 8, 7, 1, 0, 0 ]\n\nO comprimento da sequência é o número de passos que precisamos fazer até a sequência vira periódica. Ache o número entre \\(1\\) e \\(1000\\) que produz o sequência com maior comprimento.\n\nEste projeto foi inspirado pelo seguinte vídeo",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Projeto: A sequência alíquota</span>"
    ]
  },
  {
    "objectID": "rsa.html",
    "href": "rsa.html",
    "title": "8  Criptografia RSA",
    "section": "",
    "text": "8.1 A Teoria da Criptografia\nNa área da criptografia, a suposição geral é que dois parceiros (que podem ser duas pessoas, ou dois computadores) querem trocar informação sigilosa usando um canal de comunicação que está disponível para terceiros. Os dois parceiros geralmente chamam-se A(lice) e B(ob) e um possível terceiro chama-se E(va). Assume-se que as mensagens enviadas por Alice e Bob são números. A Eva consegue interceptar as mensagens enviadas. O objetivo é desenvolver métodos seguros de codificação para as mensagens que podem garantir que Eva não vai conseguir descodificar as mensagens interceptadas.\nUm método, conhecido como criptografia RSA, foi desenvolvido pelos matemáticos Ron Rivest, Adi Shamir, and Leonard Adleman e foi publicado em 1977.\nLembre que a função \\(\\varphi\\) de Euler é definida como \\[\n\\varphi(n)=|\\{a\\in\\{1,\\ldots,n\\}\\mid \\mbox{mdc}(a,n)=1\\}|\n\\] para todo natural \\(n\\). Temos, para primos \\(p\\) e \\(q\\) distintos, que \\[\n\\varphi(pq)=(p-1)(q-1).\n\\]\nAssuma que Alice quer enviar uma mensagem para Bob. Eles seguem os seguintes passos:",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Criptografia RSA</span>"
    ]
  },
  {
    "objectID": "rsa.html#a-teoria-da-criptografia",
    "href": "rsa.html#a-teoria-da-criptografia",
    "title": "8  Criptografia RSA",
    "section": "",
    "text": "Bob escolhe um número \\(n\\) tal que \\(n\\) é produto de dois primos \\(p\\) e \\(q\\) e escolhe um número \\(c\\in\\{2,\\ldots,n-1\\}\\) tal que \\(\\mbox{mdc}(c,\\varphi(n))=1\\). Isso implica que \\(c\\) é invertível módulo \\(\\varphi(n)\\); ou seja existe \\(d\\in\\{1,\\ldots,\\varphi(n)\\}\\) tal que \\[\ncd\\equiv 1\\pmod{\\varphi(n)}.\n\\]\nBob publica o par \\((n,c)\\) dos números. Este é a chave pública do Bob e está disponível publicamente para toda pessoa que quer enviar mensagem sigilosa para o Bob. Em particular esta chave é conhecida por Alice.\nO Bob guarda os números \\((\\varphi(n),d)\\) em sigilo. Esta é a chave privada do Bob.\nA mensagem da Alice é um número \\(b\\) entre \\(1\\) e \\(n\\). A Alice vai calcular \\[\nC(b)=\\mbox{o resto de $b^c$ por $n$}.\n\\] Note que Alice conhece os números \\(c\\) e \\(n\\) e consegue calcular \\(C(b)\\). O número \\(C(b)\\) é a mensagem codificada.\nAlice envia \\(C(b)\\) para o Bob.\nAo receber a mensagem \\(b_1=C(b)\\) da Alice, Bob calcula \\[\nD( b_1)=\\mbox{o resto de $b_1^c$ módulo $n$}.\n\\] O número obtido \\(D(b_1)\\) é a mensagem descodificada.\nO número \\(D(b_1)\\) coincide com a mensagem original \\(b\\) da Alice; ou seja, o Bob conseguiu descodificar a mensagem da Alice.\n\n\nTeorema 8.1 Usando a notação acima, \\(D(C(b))=b\\) para todo \\(b\\in\\{1,\\ldots,n-1\\}\\). Ou seja, usando a função \\(D\\), o Bob consegue descodificar a mensagem da Alice",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Criptografia RSA</span>"
    ]
  },
  {
    "objectID": "rsa.html#tarefa-1-exploração-interativa",
    "href": "rsa.html#tarefa-1-exploração-interativa",
    "title": "8  Criptografia RSA",
    "section": "8.2 Tarefa 1: Exploração interativa",
    "text": "8.2 Tarefa 1: Exploração interativa\nAssuma que trabalhamos com um protocolo simplificado; ou seja, vamos criar um protocolo de criptografia de 100 bits. Usando NextPrimeInt ache dois primos pe q tal que o produto é um numero composto entre \\(2^{99}\\) e \\(2^{100}-1\\). Por motivos de segurança, é recomendável que os primos p e q não sejam próximos, mas também não queremos que um deles seja pequeno. Nós vamos atingir este critério por escolher o primo p com 60 bits, enquanto o primo q terá de 40 bits.\ngap&gt; p := NextPrimeInt( Random( 2^59, 2^60 ));\n1086726084099436427\ngap&gt; q := NextPrimeInt( Random( 2^39, 2^40 ));\n1073930166469\ngap&gt; n := p*q;\n1167067924403112255997192566263\ngap&gt; n &lt;= 2^100;\ntrue\nEXPLICAR QUE RANDOM NÃO VAI DEVOLVER A MESMA COISA\nPara criar as chaves ce d, usaremos aritmética modular. Vamos criar os anéis R e R1 de classes residuais módulo ne \\(\\varphi(n)=(p-1)(q-1)\\).\nREFAZER USANDO MDC CALCULAR 2^c DIRETAMENTE. CONTROL C CHAMAR ATENÇÃO À EXPONENCIAÇÃO RÁPIDA\ngap&gt; R := ZmodnZ( n );\n(Integers mod 1167067924403112255997192566263)\ngap&gt; R1 := ZmodnZ( (p-1)*(q-1) );\n(Integers mod 1167067924402025528839162963368)\ngap&gt; c := Random( R1 );\nZmodnZObj( 449601717067465409204371741486, 1167067924402025528839162963368 )\ngap&gt; IsUnit( c );\nfalse\ngap&gt; c := Random( R1 );\nZmodnZObj( 564525934207952237103150572399, 1167067924402025528839162963368 )\ngap&gt; IsUnit( c );\ntrue\ngap&gt; d := c^-1;\nZmodnZObj( 477861003212806940664702229055, 1167067924402025528839162963368 )\ngap&gt; c := Int( c );\n564525934207952237103150572399\ngap&gt; d := Int( d );\n477861003212806940664702229055\nTendo criado, estes números, assuma que temos uma mensagem a que é um número entre 2 e n. Vamos criptografar e descriptografar a mensagem.\ngap&gt; msg2 := 2*One( R );\nZmodnZObj( 2, 1167067924403112255997192566263 )\ngap&gt; msg2_cript := msg2^c;\nZmodnZObj( 409777624988356516250582182849, 1167067924403112255997192566263 )\ngap&gt; msg2_descript := msg2_cript^d;\nZmodnZObj( 2, 1167067924403112255997192566263 )\ngap&gt; msg_rand := Random( R );\nZmodnZObj( 417408283977422861261533080164, 1167067924403112255997192566263 )\ngap&gt; msg_rand_cript := msg_rand^c;\nZmodnZObj( 117680927883705414410064163455, 1167067924403112255997192566263 )\ngap&gt; msg_rand_descript := msg_rand_cript^d;\nZmodnZObj( 417408283977422861261533080164, 1167067924403112255997192566263 )\ngap&gt; msg_rand_descript = msg_rand;\ntrue",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Criptografia RSA</span>"
    ]
  },
  {
    "objectID": "rsa.html#tarefa-2",
    "href": "rsa.html#tarefa-2",
    "title": "8  Criptografia RSA",
    "section": "8.3 Tarefa 2",
    "text": "8.3 Tarefa 2\nRepita a computação anterior, mas agora com números maiores. Em vez de trabalhar com chave de comprimento de 100 bits, trabalhe com chave de 2048 bits que é o usual com protocolos modernos de criptografia RSA. O comprimento de p será de 1228 bits, enquanto o comprimento de q será de 820 bits. (Ou seja, p é um primo entre \\(2^{1227}\\) e \\(2^{1228}-1\\)) e q é primo entre \\(2^{819}\\) e \\(2^{820}-1\\).\nÚnica coisa que precisa modificar é que a função NextPrimeInt não funciona para estes típos de números e precisa usar NextProbablyPrimeInt.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Criptografia RSA</span>"
    ]
  },
  {
    "objectID": "rsa.html#tarefa-3",
    "href": "rsa.html#tarefa-3",
    "title": "8  Criptografia RSA",
    "section": "8.4 Tarefa 3",
    "text": "8.4 Tarefa 3\nEscreva uma função RSA_keys( nr_bits ) que gera dados necessários para criptografia RSA usando nr_bits. Ou seja, RSA_keys( nr_bits ) devolve\n\no número n que é produto dos primos p e q (mas não devolve os números p e q);\ndevolve a chave pública c e a chave privada d.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Criptografia RSA</span>"
    ]
  },
  {
    "objectID": "centralizers.html",
    "href": "centralizers.html",
    "title": "9  Projeto: Uma exploração dos centralizadores",
    "section": "",
    "text": "9.1 Os fundamentos teóricos\nRecordamos que o centralizador de um elemento \\(x\\) em um grupo \\(G\\) é definido por \\[\nC_{G}(x) = \\{g \\in G | \\ gx=xg \\}.\n\\]\nDenote por \\(\\mbox{Cent}(G)\\) o conjunto de todos os centralizadores de elementos de \\(G\\). O estudo de \\(\\mbox{Cent}(G)\\) tem chamado a atenção de muitos pesquisadores. Essencialmente, as duas principais motivações para se estudar \\(\\mbox{Cent}(G)|\\) é responder essencialmente duas questões:\nNeste projeto, queremos usar o GAP para resolver algumas questões para grupos simples finitos.\nFAZER UM EXEMPLO PEQUENO S3",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Projeto: Uma exploração dos centralizadores</span>"
    ]
  },
  {
    "objectID": "centralizers.html#os-fundamentos-teóricos",
    "href": "centralizers.html#os-fundamentos-teóricos",
    "title": "9  Projeto: Uma exploração dos centralizadores",
    "section": "",
    "text": "Dado um grupo \\(G\\), o que se pode dizer sobre \\(|\\mbox{Cent}(G)|\\)?\nSe é conhecido o valor de \\(|\\mbox{Cent}(G)|\\), o que se pode dizer a respeito do grupo \\(G\\)?",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Projeto: Uma exploração dos centralizadores</span>"
    ]
  },
  {
    "objectID": "centralizers.html#tarefa-1",
    "href": "centralizers.html#tarefa-1",
    "title": "9  Projeto: Uma exploração dos centralizadores",
    "section": "9.2 Tarefa 1",
    "text": "9.2 Tarefa 1\nVamos determinar o centralizador de um elemento em um grupo. Considere o seguinte exemplo.\ngap&gt; G := AlternatingGroup( 5 );\nAlt( [ 1 .. 5 ] )\ngap&gt; x := (1,2,3);\n(1,2,3)\ngap&gt; Cx := Centralizer( G, x );\nGroup([ (1,2,3) ])\ngap&gt; Size( Cx );\n3\nSeguindo o exemplo em cima, determine os seguintes centralizadores \\(C_G(x)\\).\n\n\\(G=S_6\\), \\(x=(1,2,3)(4,5,6)\\).\netc",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Projeto: Uma exploração dos centralizadores</span>"
    ]
  },
  {
    "objectID": "centralizers.html#tarefa-2",
    "href": "centralizers.html#tarefa-2",
    "title": "9  Projeto: Uma exploração dos centralizadores",
    "section": "9.3 Tarefa 2",
    "text": "9.3 Tarefa 2\nFAZER EXEMPLO MENOR PRIMEIRO COM LIST E DEPOIS COM SET\nPara investigar o problema em cima, nós precisamos determinar o conjunto dos centralizadores em um grupo dado. Vamos fazer esta computação com o grupo \\(S_5\\).\ngap&gt; G := SymmetricGroup( 3 );\nSym( [ 1 .. 3 ] )\ngap&gt; cent := List( G, x-&gt;Centralizer( G, x ));\n[ Group([ (1,3), (2,3) ]), Group([ (2,3) ]), Group([ (1,3) ]), Group([ (1,3,2) ]), \n  Group([ (1,2,3) ]), Group([ (1,2) ]) ]\ngap&gt; cent[5] = cent[6];\nfalse\ngap&gt; cent[4] = cent[5];\ntrue\ngap&gt; cent_set := Set( G, x-&gt;Centralizer( G, x ));\n[ Group([ (2,3) ]), Group([ (1,3), (2,3) ]), Group([ (1,2) ]), Group([ (1,3,2) ]), \n  Group([ (1,3) ]) ]\ngap&gt; Size( cent );\n6\ngap&gt; Size( cent_set );\n5\nOu seja, \\(S_3\\) possui 5 centralizadores. Note que usamos a função Set que vai devolver um conjunto; ou seja, todo elemento do output será aparece apenas uma vez.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Projeto: Uma exploração dos centralizadores</span>"
    ]
  },
  {
    "objectID": "centralizers.html#tarefa-3",
    "href": "centralizers.html#tarefa-3",
    "title": "9  Projeto: Uma exploração dos centralizadores",
    "section": "9.4 Tarefa 3",
    "text": "9.4 Tarefa 3\nEscreva uma função Cent(G) para computar o conjunto de todos os centralizadores de elementos de um grupo \\(G\\) dado. Use a função Centralizer(G,x).\nFAZER EXEMPLOS SEM SIZE\nSua função deve verificar:\ngap&gt; Size(Cent(SymmetricGroup(3)));\n5\ngap&gt; Size(Cent(AlternatingGroup(5)));\n22 \ngap&gt; Size(Cent(AlternatingGroup(6)));\n137\ngap&gt; Size(Cent(AlternatingGroup(5)));\n807\ngap&gt; Size(Cent(PSL(2,7));\n79\ngap&gt; Size(Cent(PSL(3,3));\n1185\ngap&gt; Size(Cent(DihedralGroup(8)));\n4\ngap&gt; Size(SmallGroup(16,7));\n6\ngap&gt; Size(Cent(MathieuGroup(11));\n2081",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Projeto: Uma exploração dos centralizadores</span>"
    ]
  },
  {
    "objectID": "centralizers.html#tarefa-4",
    "href": "centralizers.html#tarefa-4",
    "title": "9  Projeto: Uma exploração dos centralizadores",
    "section": "9.5 Tarefa 4",
    "text": "9.5 Tarefa 4\nA lista a seguir possui somente ordens de grupos simples não abelianos (com repetição):\n[60, 168, 360, 504, 660, 1092, 2448, 2520, 3420, 4080, 5616, 6048, 6072, 7800, 7920, \n 9828, 12180, 14880, 20160, 20160, 25308, 25920, 29120, 32736, 34440, 39732, 51888, \n 58800, 62400, 74412, 95040, 102660, 113460, 126000, 150348]\nExplore a função AllSmallNonabelianSimpleGroups([60..n]), para \\(n\\) no conjunto acima. Por exemplo:\ngap&gt; AllSmallNonabelianSimpleGroups([60..20160]);\n[ A5, PSL(2,7), A6, PSL(2,8), PSL(2,11), PSL(2,13), PSL(2,17), A7, PSL(2,19), PSL(2,16), PSL(3,3), PSU(3,3), PSL(2,23), PSL(2,25), M11, PSL(2,27), PSL(2,29), PSL(2,31), A8, PSL(3,4)]",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Projeto: Uma exploração dos centralizadores</span>"
    ]
  },
  {
    "objectID": "centralizers.html#tarefa-5",
    "href": "centralizers.html#tarefa-5",
    "title": "9  Projeto: Uma exploração dos centralizadores",
    "section": "9.6 Tarefa 5",
    "text": "9.6 Tarefa 5\nAgora você precisa responder a seguinte questão\n\n[Questão de Ashrafi e Taeri] Sejam \\(G\\) e \\(H\\) grupos simples não abelianos. É verdade que se \\(|\\mbox{Cent}(G)| = |\\mbox{Cent}(H)|\\), então \\(G\\) é isomorfo a \\(H\\)?\n\nTente para os grupos da tarefa anterior.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Projeto: Uma exploração dos centralizadores</span>"
    ]
  },
  {
    "objectID": "centralizers.html#tarefa-6",
    "href": "centralizers.html#tarefa-6",
    "title": "9  Projeto: Uma exploração dos centralizadores",
    "section": "9.7 Tarefa 6",
    "text": "9.7 Tarefa 6\nE se restringirmos a função para sabermos a quantidade de centralizadores abelianos de um grupo? Será que se dois grupos simples não abelianos tiverem a mesma quantidade de centralizadores abelianos de elementos, esses grupos são necessariamente isomorfos?\nFaça uma mudança no seu código e crie uma função abCent(G) para computar o conjunto de centralizadores abelianos de elementos. Posteriormente, responda a questão desta tarefa.\nPor fim, o que podemos dizer para o caso de centralizadores não abelianos de elementos?\nCOLOCAR ISOCLINISMO!!!",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Projeto: Uma exploração dos centralizadores</span>"
    ]
  },
  {
    "objectID": "commutators.html",
    "href": "commutators.html",
    "title": "10  Projeto: Comutadores",
    "section": "",
    "text": "10.1 A Teoria\nSeja \\(G\\) um grupo. Se \\(x,y\\in G\\), então o comutador \\([x,y]\\) está definido como \\[\n[x,y]=x^{-1}y^{-1}xy.\n\\] O subgrupo derivado \\(G'\\) de \\(G\\) é definido como o subgrupo de \\(G\\) gerado por todos os comutadores; ou seja, \\[\nG'=\\left&lt;[x,y]\\mid x,y\\in G\\right&gt;.\n\\] É importante observar que o subgrupo derivado por definição não é apenas o conjunto dos comutadores, mas ele é o subgrupo gerado por este conjunto. Isso é porque o conjunto de comutadores pode não ser um subgrupo. No entanto, nos grupos pequeno \\(G'\\) coincide com o conjunto de comutadores.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Projeto: Comutadores</span>"
    ]
  },
  {
    "objectID": "commutators.html#tarefa-1",
    "href": "commutators.html#tarefa-1",
    "title": "10  Projeto: Comutadores",
    "section": "10.2 Tarefa 1",
    "text": "10.2 Tarefa 1\nVamos explorar o conjunto de comutadores em um grupo dado. Considere por exemplo o grupo SymmetricGroup( 5 ). Vamos primeiro calcular o comutador de dois elementos.\ngap&gt; G := SymmetricGroup( 5 );\nSym( [ 1 .. 5 ] )\ngap&gt; x := (1,2,3,4,5);\n(1,2,3,4,5)\ngap&gt; y := (1,2);\n(1,2)\ngap&gt; x in G;\ntrue\ngap&gt; y in G;\ntrue\ngap&gt; Comm( x, y );\n(1,2,3)\ngap&gt; Comm( x, y ) = x^-1*y^-1*x*y;\ntrue\nOra, vamos computar o conjunto de comutadores de \\(G\\) e comparamos este conjunto com o subgrupo derivado.\ngap&gt; comms := Set( Tuples( Elements( G ), 2 ), t-&gt;Comm( t[1],t[2]));\n[ (), (3,4,5), (3,5,4), (2,3)(4,5), (2,3,4), (2,3,5), (2,4,3), (2,4,5), \n  (2,4)(3,5), (2,5,3), (2,5,4), (2,5)(3,4), (1,2)(4,5), (1,2)(3,4), \n  (1,2)(3,5), (1,2,3), (1,2,3,4,5), (1,2,3,5,4), (1,2,4,5,3), (1,2,4), \n  (1,2,4,3,5), (1,2,5,4,3), (1,2,5), (1,2,5,3,4), (1,3,2), (1,3,4,5,2), \n  (1,3,5,4,2), (1,3)(4,5), (1,3,4), (1,3,5), (1,3)(2,4), (1,3,2,4,5), \n  (1,3,5,2,4), (1,3)(2,5), (1,3,2,5,4), (1,3,4,2,5), (1,4,5,3,2), (1,4,2), \n  (1,4,3,5,2), (1,4,3), (1,4,5), (1,4)(3,5), (1,4,5,2,3), (1,4)(2,3), \n  (1,4,2,3,5), (1,4,2,5,3), (1,4,3,2,5), (1,4)(2,5), (1,5,4,3,2), (1,5,2), \n  (1,5,3,4,2), (1,5,3), (1,5,4), (1,5)(3,4), (1,5,4,2,3), (1,5)(2,3), \n  (1,5,2,3,4), (1,5,2,4,3), (1,5,3,2,4), (1,5)(2,4) ]\ngap&gt; Size( comms );\n60\ngap&gt; comms = Set( DerivedSubgroup( G ));\ntrue\nA computação em cima mostra que, no caso do grupo \\(S_5\\), o subgrupo derivado coincide com o conjunto de comutadores.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Projeto: Comutadores</span>"
    ]
  },
  {
    "objectID": "commutators.html#tarefa-2",
    "href": "commutators.html#tarefa-2",
    "title": "10  Projeto: Comutadores",
    "section": "10.3 Tarefa 2",
    "text": "10.3 Tarefa 2\nEscreva uma função nr_comps( G ) que para um grupo G dado, computa o número de comutadores distintos de G. A sua função deve verificar:\ngap&gt; nr_comms( SymmetricGroup( 5 ));\n60\ngap&gt; nr_comms( AlternatingGroup( 5 ));\n60\ngap&gt; nr_comms( DihedralGroup( 20  ));\n5\ngap&gt; nr_comms( AlternatingGroup( 4  ));\n4\ngap&gt; nr_comms( PGL( 2, 7 ));\n168\ngap&gt; Size( DerivedSubgroup( SymmetricGroup( 5 )));\n60\ngap&gt; Size( DerivedSubgroup( AlternatingGroup( 5 )));\n60\ngap&gt; Size( DerivedSubgroup( DihedralGroup( 10 )));\n5\ngap&gt; Size( DerivedSubgroup( PGL( 2,7 )));\n168",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Projeto: Comutadores</span>"
    ]
  },
  {
    "objectID": "commutators.html#tarefa-3",
    "href": "commutators.html#tarefa-3",
    "title": "10  Projeto: Comutadores",
    "section": "10.4 Tarefa 3",
    "text": "10.4 Tarefa 3\nEscreva uma função commutator_set_is_subgroup( G ) para verificar se o conjunto de comutadores é igual ao subgrupo derivado de um grupo G. A função deve devolver true ou false. Note que é suficiente verificar se a cardinalidade do conjunto de comutadores é igual à cardinalidade do subgrupo derivado. A sua função deve seguir os seguintes exemplos.\ngap&gt; commutator_set_is_subgroup( SymmetricGroup( 5 ));\ntrue\ngap&gt; commutator_set_is_subgroup( AlternatingGroup( 5 ));\ntrue\ngap&gt; commutator_set_is_subgroup( DihedralGroup( 10 ));\ntrue\ngap&gt; commutator_set_is_subgroup( PGL( 2, 7 ));\ntrue",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Projeto: Comutadores</span>"
    ]
  },
  {
    "objectID": "commutators.html#tarefa-4",
    "href": "commutators.html#tarefa-4",
    "title": "10  Projeto: Comutadores",
    "section": "10.5 Tarefa 4",
    "text": "10.5 Tarefa 4\nUsando a função SmallGroup( n, k ), ache o menor grupo G tal que o conjunto de comutadores de G não é o grupo derivado. Por exemplo, vamos verificar que entre os grupos de ordem 24 isso não ocorre.\ngap&gt; max_k := NrSmallGroups( 24 );\n15\ngap&gt; List( [1..15], x -&gt; commutator_set_is_subgroup( SmallGroup( 24, x )));\n[ true, true, true, true, true, true, true, true, true, true, true, true, \n  true, true, true ]",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Projeto: Comutadores</span>"
    ]
  },
  {
    "objectID": "commutators.html#tarefa-5",
    "href": "commutators.html#tarefa-5",
    "title": "10  Projeto: Comutadores",
    "section": "10.6 Tarefa 5",
    "text": "10.6 Tarefa 5\nO COMPRIMENTO DOS PRODUTOS",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Projeto: Comutadores</span>"
    ]
  },
  {
    "objectID": "groebner1.html",
    "href": "groebner1.html",
    "title": "11  Polynômios, ideais, e um problema de triângulos",
    "section": "",
    "text": "11.1 Polynômios em GAP\nIndeterminados, polinômios e anéis de polinômios podem ser definidos em GAP na maneira seguinte.\nNote que podemos também definir ideais\nConsidere \\[\nh=x^2yz-xz^3-x^3-xz^2+xy-z^2.\n\\] Verifiquemos se \\(h\\) pertence ao ideal \\(I=(f,g)\\).\nPortanto \\(h\\) pode ser escrito na forma \\[\nh=uf+vg\\quad\\mbox{com}\\quad u,v\\in\\mathbb Q[x,y,z].\n\\] Vamos ver como achar os polinômios \\(u\\) e \\(v\\).\nO resultado indica que o resto de \\(h\\) em relação ao ideal \\(I\\) é \\(0\\) e os dois polinômios do segundo componente do output podem ser tomados para \\(u\\) e \\(v\\).",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Polynômios, ideais, e um problema de triângulos</span>"
    ]
  },
  {
    "objectID": "groebner1.html#polynômios-em-gap",
    "href": "groebner1.html#polynômios-em-gap",
    "title": "11  Polynômios, ideais, e um problema de triângulos",
    "section": "",
    "text": "gap&gt; x := Indeterminate( Rationals, \"x\" );\nx\ngap&gt; y := Indeterminate( Rationals, \"y\" );\ny\ngap&gt; z := Indeterminate( Rationals, \"z\" );\nz\ngap&gt; P := PolynomialRing( Rationals, [x,y,z] );\nRationals[x,y,z]\ngap&gt; f := x*y-z^2;\nx*y-z^2\ngap&gt; g := x^2+z^2;\nx^2+z^2\ngap&gt; f*g;\nx^3*y-x^2*z^2+x*y*z^2-z^4\n\ngap&gt; I := Ideal( P, [f,g] );\n&lt;two-sided ideal in Rationals[x,y,z], (2 generators)&gt;\n\ngap&gt; h := h=x^2*y*z-x*z^3-x^3-x*z^2+x*y-z^2;\ngap&gt; I := Ideal( P, [f,g] );\n&lt;two-sided ideal in Rationals[x,y,z], (2 generators)&gt;\ngap&gt; h in I;\ntrue\n\ngap&gt; PolynomialReduction( h, [f,g], MonomialLexOrdering() );\n[ 0, [ x*z+1, -x ] ]\n\ngap&gt; h = (x*z+1)*f-x*g\ntrue",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Polynômios, ideais, e um problema de triângulos</span>"
    ]
  },
  {
    "objectID": "groebner1.html#as-medianas-de-um-triângulo",
    "href": "groebner1.html#as-medianas-de-um-triângulo",
    "title": "11  Polynômios, ideais, e um problema de triângulos",
    "section": "11.2 As medianas de um triângulo",
    "text": "11.2 As medianas de um triângulo\nSeja \\(\\Delta=ABC\\) um triângulo no plano. A reta que conecta uma ponta de \\(\\Delta\\) com o ponto meio do lado oposto chama-se mediana. Está bem conhecido que as medianas se interceptam em um ponto chamado de baricentro de \\(\\Delta\\). Neste projeto provaremos este fato usando álgebra comutativa.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Polynômios, ideais, e um problema de triângulos</span>"
    ]
  },
  {
    "objectID": "groebner1.html#o-modelo-algébrico",
    "href": "groebner1.html#o-modelo-algébrico",
    "title": "11  Polynômios, ideais, e um problema de triângulos",
    "section": "11.3 O modelo algébrico",
    "text": "11.3 O modelo algébrico\nAssuma sem perder generalidade que as três pontas do triângulo são \\[\\begin{align*}\nA & = (0,0);\\\\\nB & = (1,0);\\\\\nC & = (x,y).\n\\end{align*}\\] Assuma que \\(P\\), \\(Q\\) e \\(R\\) são os pontos médios dos lados \\(BC\\), \\(AC\\) e \\(AB\\). Portanto, \\[\\begin{align*}\nP & = ((x+1)/2,y/2);\\\\\nQ & = (x/2,y/2);\\\\\nR & = (1/2,0).\n\\end{align*}\\] Assuma que \\(S=(u,v)\\) é o pnnto de interseção das retas \\(AP\\) e \\(BQ\\). Precisa provar que a reta \\(CR\\) passa pelo ponto \\(S\\). Os fatos que \\(S\\) está na reta \\(AP\\) e que \\(S\\) está na reta \\(BQ\\) podem ser expressas das equações \\[\\begin{align*}\n\\frac uv=\\frac{x+1}y;\\\\\n\\frac{x-2}y=\\frac{u-1}v.\n\\end{align*}\\] Como o triângulo não é degenerado, temos que \\(u\\neq 0\\), \\(v\\neq 0\\) e \\(y\\neq 0\\) e estas equações são equivalentes com as equações \\[\\begin{align*}\nf_1&=uy-v(x+1)=0;\\\\\nf_2&=(x-2)u-(u-1)y=0.\n\\end{align*}\\] Similarmente, o fato que \\(S\\) está na reta \\(CR\\) pode ser expressa pela equação \\[\n\\frac{u-1/2}v=\\frac{x-1/2}y;\n\\] ou seja, \\[\nf_3=-2xv+2yu-y+v=0.\n\\]\nNote que o fato que \\(S\\) está na reta \\(CR\\) é equivalente à afirmação que \\[\nf_3=(f_1,f_2).\n\\]",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Polynômios, ideais, e um problema de triângulos</span>"
    ]
  },
  {
    "objectID": "groebner1.html#tarefa-1",
    "href": "groebner1.html#tarefa-1",
    "title": "11  Polynômios, ideais, e um problema de triângulos",
    "section": "11.4 Tarefa 1",
    "text": "11.4 Tarefa 1\nFaça as seguintes computações com GAP.\n\nDefina o anel de polinômios \\(\\mathbb Q[x,y,u,v]\\).\nDefina os polinômios \\(f_1,f_2,f_3\\) em cima.\nVerifique se \\(f_3\\in(f_1,f_2)\\).\nEscreva \\(f_3\\) na forma \\[\nf_3=h_1f_1+h_2f_2\n\\] onde \\(h_i\\in\\mathbb Q[x,y,u,v]\\).",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Polynômios, ideais, e um problema de triângulos</span>"
    ]
  },
  {
    "objectID": "groebner1.html#tarefa-2",
    "href": "groebner1.html#tarefa-2",
    "title": "11  Polynômios, ideais, e um problema de triângulos",
    "section": "11.5 Tarefa 2",
    "text": "11.5 Tarefa 2\nO modelo algébrico não incluiu a informação que o triângulo é não degenerado; ou seja, \\(y\\neq 0\\). Esta condição pode ser incluída no modelo por introduzir uma nova variável \\(Y\\) e uma nova equação \\[\nf_4=Yy-1=0.\n\\]\n\nFaça as computações na Tarefa 1 incluindo o polinômio \\(f_4\\).",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Polynômios, ideais, e um problema de triângulos</span>"
    ]
  },
  {
    "objectID": "groebner1.html#tarefa-3",
    "href": "groebner1.html#tarefa-3",
    "title": "11  Polynômios, ideais, e um problema de triângulos",
    "section": "11.6 Tarefa 3",
    "text": "11.6 Tarefa 3\nDemonstre que o ponto \\(S\\) divide as medianas em duas partes cuja razão é \\(1:2\\). Note que esta afirmação é equivalente à equação \\[\n3|RS|=3(u-1/2,v)=(x-1/2,y)=|RC|.\n\\] Ou seja, precisa verificar que \\[\n3u-x-1,\\ 3v-y\\in (f_1,f_2).\n\\]\n\nVerifique se estes dois polinômios estão no ideal \\((f_1,f_2)\\).\nEscreve-os na forma \\[\nh_1f_1+h_2f_2.\n\\]",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Polynômios, ideais, e um problema de triângulos</span>"
    ]
  },
  {
    "objectID": "genord.html",
    "href": "genord.html",
    "title": "12  Carateres de um grupo e a ordem generalizada",
    "section": "",
    "text": "12.1 Carateres de grupos\nSeja \\(G\\) um grupo finito e seja \\(\\varrho:G\\to \\operatorname{GL}(n,\\mathbb C)\\) um homomorfismo. O homomorfismo \\(\\varrho\\) chama-se também uma representação linear de \\(G\\). O carater associado com \\(\\varrho\\) é \\[\n\\chi:G\\to\\mathbb C,\\quad \\chi(g)=\\mbox{trace}(\\varrho(g)).\n\\] Note que \\(\\mbox{trace}\\) significa o traço da matriz \\(\\varrho(g)\\); ou seja, a soma dos elementos na diagonal principal. É bem conhecido que o caracter carrega muita informação sobre \\(\\varrho\\).\nEm GAP, carateres podem ser calculados na seguinte maneira. Note que estamos interessados principalmente nos carateres que correspondem às representações irredutíveis.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Carateres de um grupo e a ordem generalizada</span>"
    ]
  },
  {
    "objectID": "genord.html#carateres-de-grupos",
    "href": "genord.html#carateres-de-grupos",
    "title": "12  Carateres de um grupo e a ordem generalizada",
    "section": "",
    "text": "gap&gt; G := SmallGroup( 24, 10 );\n&lt;pc group of size 24 with 4 generators&gt;\ngap&gt; t := CharacterTable( G );\nCharacterTable( &lt;pc group of size 24 with 4 generators&gt; )\ngap&gt; irr := Irr( t );\n[ Character( CharacterTable( &lt;pc group of size 24 with 4 generators&gt; ),\n  [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ), \n  Character( CharacterTable( &lt;pc group of size 24 with 4 generators&gt; ),\n  [ 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1 ] ), \n...etc...\ngap&gt; irr[3];\nCharacter( CharacterTable( &lt;pc group of size 24 with 4 generators&gt; ),\n [ 1, -1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, 1, 1, -1 ] )",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Carateres de um grupo e a ordem generalizada</span>"
    ]
  },
  {
    "objectID": "genord.html#a-ordem-generalizada",
    "href": "genord.html#a-ordem-generalizada",
    "title": "12  Carateres de um grupo e a ordem generalizada",
    "section": "12.2 A ordem generalizada",
    "text": "12.2 A ordem generalizada\nSeja \\(G\\) um grupo e \\(x\\in G\\). A ordem generalizada \\([x]\\) de \\(x\\) é o menor número natural \\(k\\) tal que a identidade \\(1\\) de \\(G\\) pode ser escrito como um produto de \\(k\\) conjugados de \\(x\\). Ou seja, \\([x]\\) é o menor natural \\(k\\) tal que \\[\nx^{g_1}\\cdots x^{g_k}=1\n\\] com algum \\(g_1,\\ldots,g_k\\in G\\).",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Carateres de um grupo e a ordem generalizada</span>"
    ]
  },
  {
    "objectID": "genord.html#a-ordem-generalizada-usando-carateres",
    "href": "genord.html#a-ordem-generalizada-usando-carateres",
    "title": "12  Carateres de um grupo e a ordem generalizada",
    "section": "12.3 A ordem generalizada usando carateres",
    "text": "12.3 A ordem generalizada usando carateres\n\nTeorema 12.1 Seja \\(G\\) um grupo finito e seja \\(g\\in G\\). Defina \\[\n\\alpha_{g,k}=\\frac {|G|^{k-1}}{|C_G(g)|^k}\\sum_{\\chi\\in\\mbox{Irr}(G)}\\frac{\\chi(g)^k}{\\chi(1)^{k-2}}.\n\\] Então \\(\\alpha_{g,k}\\) é um número natural e ele é igual ao número de maneiras de escrever a identidade \\(1\\) de \\(G\\) como produto de conjugados de \\(g\\). Em particular, \\[\n[g]=\\min\\{k\\geq 1\\mid \\alpha_{g,k}\\geq 1\\}.\n\\]",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Carateres de um grupo e a ordem generalizada</span>"
    ]
  },
  {
    "objectID": "genord.html#tarefa-1",
    "href": "genord.html#tarefa-1",
    "title": "12  Carateres de um grupo e a ordem generalizada",
    "section": "12.4 Tarefa 1",
    "text": "12.4 Tarefa 1\nVamos calcular a ordem generalizada de um elemento do grupo dihedral \\(D_8\\). Usando a fórmula anterior.\ngap&gt; D8 := DihedralGroup( 8 );\n&lt;pc group of size 8 with 3 generators&gt;\ngap&gt; t := CharacterTable( D8 );\nCharacterTable( &lt;pc group of size 8 with 3 generators&gt; )\ngap&gt; OrdersClassRepresentatives( t );\n[ 1, 2, 4, 2, 2 ]\ngap&gt; irr := Irr( t );\n[ Character( CharacterTable( &lt;pc group of size 8 with 3 generators&gt; ),\n  [ 1, 1, 1, 1, 1 ] ), Character( CharacterTable( &lt;pc group of size 8 with \n    3 generators&gt; ), [ 1, -1, 1, 1, -1 ] ), \n  Character( CharacterTable( &lt;pc group of size 8 with 3 generators&gt; ),\n  [ 1, 1, -1, 1, -1 ] ), Character( CharacterTable( &lt;pc group of size 8 with \n    3 generators&gt; ), [ 1, -1, -1, 1, 1 ] ), \n  Character( CharacterTable( &lt;pc group of size 8 with 3 generators&gt; ),\n  [ 2, 0, 0, -2, 0 ] ) ]\ngap&gt; k := 1;; Sum( List( irr, x-&gt;x[3]^k/x[1]^(k-2) ));\n0\ngap&gt; k := 2;; Sum( List( irr, x-&gt;x[3]^k/x[1]^(k-2) ));\n4\nNote que obtemos que o ordem generalizada de \\(a\\) é \\(8\\).",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Carateres de um grupo e a ordem generalizada</span>"
    ]
  },
  {
    "objectID": "genord.html#tarefa-2",
    "href": "genord.html#tarefa-2",
    "title": "12  Carateres de um grupo e a ordem generalizada",
    "section": "12.5 Tarefa 2",
    "text": "12.5 Tarefa 2",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Carateres de um grupo e a ordem generalizada</span>"
    ]
  },
  {
    "objectID": "genord.html#tarefa-3",
    "href": "genord.html#tarefa-3",
    "title": "12  Carateres de um grupo e a ordem generalizada",
    "section": "12.6 Tarefa 3",
    "text": "12.6 Tarefa 3",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Carateres de um grupo e a ordem generalizada</span>"
    ]
  },
  {
    "objectID": "genord.html#tarefa-4",
    "href": "genord.html#tarefa-4",
    "title": "12  Carateres de um grupo e a ordem generalizada",
    "section": "12.7 Tarefa 4",
    "text": "12.7 Tarefa 4",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Carateres de um grupo e a ordem generalizada</span>"
    ]
  },
  {
    "objectID": "cubo.html",
    "href": "cubo.html",
    "title": "13  Grupos livres e o cubo mágico",
    "section": "",
    "text": "13.1 O cubo mágico\nO cubo mágico, como outros brincedos de lógica, pode ser analisado usando o sistema GAP. O cubo tem 48 peças cujas posições estão ilustradas no seguinte diagrama.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Grupos livres e o cubo mágico</span>"
    ]
  },
  {
    "objectID": "cubo.html#o-cubo-mágico",
    "href": "cubo.html#o-cubo-mágico",
    "title": "13  Grupos livres e o cubo mágico",
    "section": "",
    "text": "+--------------+\n                     |              |\n                     |  1    2    3 |\n                     |              |\n                     |  4  CIMA   5 |\n                     |              |\n                     |  6    7    8 |\n                     |              |\n      +--------------+--------------+--------------+--------------+\n      |              |              |              |              |\n      |  9   10   11 | 17   18   19 | 25   26   27 | 33   34   35 |\n      |              |              |              |              |\n      | 12  ESQ   13 | 20 FRENTE 21 | 28 DIREIT 29 | 36  TRAS  37 |\n      |              |              |              |              |\n      | 14   15   16 | 22   23   24 | 30   31   32 | 38   39   40 |\n      |              |              |              |              |\n      +--------------+--------------+--------------+--------------+\n                     |              |\n                     | 41   42   43 |\n                     |              |\n                     | 44  BAIX  45 |\n                     |              |\n                     | 46   47   48 |\n                     |              |\n                     +--------------+",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Grupos livres e o cubo mágico</span>"
    ]
  },
  {
    "objectID": "cubo.html#o-grupo-do-cubo-mágico",
    "href": "cubo.html#o-grupo-do-cubo-mágico",
    "title": "13  Grupos livres e o cubo mágico",
    "section": "13.2 O grupo do cubo mágico",
    "text": "13.2 O grupo do cubo mágico\nTodo movimento pode ser visto como uma permutação dessas peças. Por exemplo girar o topo induz a permutação seguinte.\ngap&gt; c := (1,6,8,3)(2,4,7,5)(9,17,25,33)(10,18,26,34)(11,19,27,35);\nNós definimos similarmente as outras permutações que correspondem a girar os outros lados. O grupo de permutações que corresponde ao cubo é o subgrupo de \\(S_{48}\\) gerado por essas permutações.\ngap&gt; e := (1,40,41,17)(4,37,44,20)(6,35,46,22)(9,14,16,11)(10,12,15,13);\ngap&gt; f := (6,16,43,25)(7,13,42,28)(8,11,41,30)(17,22,24,19)(18,20,23,21);\ngap&gt; d := (3,19,43,38)(5,21,45,36)(8,24,48,33)(25,30,32,27)(26,28,31,29);\ngap&gt; t := (1,27,48,14)(2,29,47,12)(3,32,46,9)(33,38,40,35)(34,36,39,37);\ngap&gt; b := (14,38,30,22)(15,39,31,23)(16,40,32,24)(41,46,48,43)(42,44,47,45);\ngap&gt; G := Group( c, e, f, d, t, b );\n&lt;permutation group with 6 generators&gt;\nCalculemos a ordem de G. A ordem de G coincide com o número de configurações do cubo.\ngap&gt; Size( G );                     \n43252003274489856000\ngap&gt; Factors( last );              \n[ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, \n  2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 5, 7, 7, 11 ]\ngap&gt; Collected( last );\n[ [ 2, 27 ], [ 3, 14 ], [ 5, 3 ], [ 7, 2 ], [ 11, 1 ] ]",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Grupos livres e o cubo mágico</span>"
    ]
  },
  {
    "objectID": "cubo.html#tarefa-1",
    "href": "cubo.html#tarefa-1",
    "title": "13  Grupos livres e o cubo mágico",
    "section": "13.3 Tarefa 1",
    "text": "13.3 Tarefa 1\nVamos ver como transformar uma configuração a um elemento de \\(G\\). Considere por exemplo a seguinte configuração.\n                     +--------------+\n                     |              |\n                     |  16   4   46 |\n                     |              |\n                     |  13 CIMA  31 |\n                     |              |\n                     |  38   39   8 |\n                     |              |\n      +--------------+--------------+--------------+--------------+\n      |              |              |              |              |\n      |  22  20   32 | 48   47   19 | 25   45   14 | 40   10   41 |\n      |              |              |              |              |\n      | 29  ESQ   42 | 23 FRENTE  5 | 26 DIREIT 12 | 37   TRAS 36 |\n      |              |              |              |              |\n      | 27   15   43 | 24   21   11 | 6     7    9 | 35   34   33 |\n      |              |              |              |              |\n      +--------------+--------------+--------------+--------------+\n                     |              |\n                     | 30   28   17 |\n                     |              |\n                     | 44  BAIX  18 |\n                     |              |\n                     | 3     2   1  |\n                     |              |\n                     +--------------+\nNote que, a peça 16 aparece no lugar de 1, 4 no lugar de 2, 46 no lugar de 3, etc. Nós precisamos construir a permutação que leva \\[\n1\\mapsto 16,\\quad 2\\mapsto 4,\\quad 3\\mapsto 46,\\ldots\n\\] Esta permutação pode ser construída usando as seguintes instruções.\ngap&gt; s := [16,4,46,13,31,38,39,8,22,20,32,29,42,27,15,43,48,47,19,23,5,24,21,11,25,45,14,26,12,6,7,9,40,10,41,37,36,35,34,33,30,28,17,44,18,3,2,1];\ngap&gt; x := PermList( s );            \n(1,16,43,17,48)(2,4,13,42,28,26,45,18,47)(3,46)(5,31,7,39,34,10,20,23,21)(6,\n38,35,41,30)(9,22,24,11,32)(12,29)(14,27)(33,40)(36,37)\ngap&gt; x in G;\ntrue",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Grupos livres e o cubo mágico</span>"
    ]
  },
  {
    "objectID": "cubo.html#tarefa-2",
    "href": "cubo.html#tarefa-2",
    "title": "13  Grupos livres e o cubo mágico",
    "section": "13.4 Tarefa 2",
    "text": "13.4 Tarefa 2\nSeja \\(X\\) um grupo. Lembre que uma série \\[\nX_0&gt;X_1&gt;X_2&gt;\\cdots&gt;X_m=1\n\\] de subgrupos é dita série de composição se \\(X_{i+1}\\) é um subgrupo normal em \\(X_i\\) e \\(X_i/X_{i+1}\\) é um grupo simples para todo \\(i\\) (ou seja, \\(X_i/X_{i+1}\\) não possui subgrupo normal próprio e não trivial). A série de composição em um grupo, pode não ser única, mas sabemos pelo Teorema de Jordan-Holder que o comprimento da séries e os tipos de isomorfismo dos fatores (os fatores de composição) são unicamente determinados por \\(X\\). Estes fatores podem ser vistos como os blocos elementares do grupo similarmente aos fatores primos dos números naturais.\nNo seguinte exempolo simples vamos determinar os fatores de composição do grupo dihedral \\(D_5\\) (os simetrias do pentágono).\ngap&gt; G := DihedralGroup( 10 );\n&lt;pc group of size 10 with 2 generators&gt;\ngap&gt; C := CompositionSeries( G );\n[ Group([ f1, f2 ]), Group([ f2 ]), Group([  ]) ]\ngap&gt; List( [1..2], i-&gt;C[i]/C[i+1] );\n[ Group([ f1, &lt;identity&gt; of ... ]), Group([ f2 ]) ]\ngap&gt; List( [1..2], i-&gt;StructureDescription(C[i]/C[i+1]) );\n[ \"C2\", \"C5\" ]\nTemos que a série de composição de \\(D_5\\) tem comprimento \\(2\\) e os dois fatores são cíclicos de ordem \\(2\\) e \\(5\\).\nAgora responda às seguintes perguntas sobre o grupo \\(G\\) do cubo mágico.\n\nQual é o comprimento da série de composição do grupo \\(G\\)?\nQuantos fatores são abelianos e quantos são não abelianos.\nOs fatores abelianos, sendo grupos simples, são cíclicos; determine as suas ordens.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Grupos livres e o cubo mágico</span>"
    ]
  },
  {
    "objectID": "cubo.html#tarefa-3",
    "href": "cubo.html#tarefa-3",
    "title": "13  Grupos livres e o cubo mágico",
    "section": "13.5 Tarefa 3",
    "text": "13.5 Tarefa 3\nVamos estudar a estrutura permutacional do grupo \\(G\\).\n\nDetermine as órbitas de \\(G\\) agindo no conjunto das 48 peças.\nDê uma intepretação destas órbitas.\nLembre que um subconjunto \\(\\Delta\\) das peças chama-se bloco se \\(\\Delta g=\\Delta\\) ou \\(\\Delta g\\cap \\Delta=\\emptyset\\). Determine os blocos contidos nas órbitas de \\(G\\).\nDê interpretação destes blocos.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Grupos livres e o cubo mágico</span>"
    ]
  },
  {
    "objectID": "cubo.html#tarefa-4",
    "href": "cubo.html#tarefa-4",
    "title": "13  Grupos livres e o cubo mágico",
    "section": "13.6 Tarefa 4",
    "text": "13.6 Tarefa 4\nFinalmente nós vamos resolver o cubo usando um homomorfismo do grupo livre em G. Seja \\(F\\) o grupo livre gerado pelos geradores \\(C\\), \\(E\\), \\(F\\), \\(D\\), \\(T\\), \\(B\\). Note que \\(F\\) é gerado por \\(6\\) elementos e cada gerador de \\(F\\) corresponde a um gerador de \\(G\\). A propriedade universal do grupo livre implica que o mapa \\[\nC\\mapsto c,\\ E\\mapsto e, F\\mapsto f,\\ D\\mapsto d,\\ T\\mapsto t,\\ B\\mapsto b\n\\] pode ser extendido a um único homomorfismo \\(f:F\\to G\\). Se \\(g\\in G\\) e \\(w\\) é uma pré-imagem de \\(g\\), então \\(w\\) mostra como escrever \\(g\\) em uma palavra nas geradores de \\(G\\). Ou seja, \\(w\\) monstra como obter a configuração que corresponde ao elemento \\(g\\) como uma sequência dos \\(6\\) movimentos básicos.\nIlustramos esta ideia com um exemplo simpes usando o grupo \\(D_5\\).\ngap&gt; a := (1,2,3,4,5); b := (2,5)(3,4);\n(1,2,3,4,5)\n(2,5)(3,4)\ngap&gt; G := Group( a, b );\nGroup([ (1,2,3,4,5), (2,5)(3,4) ])\ngap&gt; F := FreeGroup( \"A\", \"B\" );\n&lt;free group on the generators [ A, B ]&gt;\ngap&gt; hom := GroupHomomorphismByImages( F, G, GeneratorsOfGroup( F ), GeneratorsOfGroup( G ));\n[ A, B ] -&gt; [ (1,2,3,4,5), (2,5)(3,4) ]\ngap&gt; x := Random( G );\n(1,4)(2,3)\ngap&gt; PreImagesRepresentative( hom, x );\nA^-1*B^-1*A^-3\nO resultado diz que a permutação \\(x=(1,4)(2,3)\\) pode ser obtida como a composição \\(a^{-1}*b^{-1}*a^{-3}\\). De fato\ngap&gt; a^-1*b^-1*a^-3 = x;\ntrue\n\nConstrua o grupo \\(F\\) em cima em GAP usando FreeGroup.\nConstrua o homomorfismo \\(f\\) em cima usando GroupHomomorphismByImages.\nConsidere a configuração do cubo na Tarefa 1. Construa a sequência dos movimentos que resulta nesta configuração.\nConsidere uma configuração aleatória do cubo por escolhendo um elemento aleatório de \\(G\\) (usando Random( G )). Construa a sequência dos movimentos que resulta nesta configuração aleatória.\nUsando um dos cubos disponibilizados por Igor e Csaba, obtenha a configuração da Tarefa 1.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Grupos livres e o cubo mágico</span>"
    ]
  },
  {
    "objectID": "cubo.html#tarefa-5",
    "href": "cubo.html#tarefa-5",
    "title": "13  Grupos livres e o cubo mágico",
    "section": "13.7 Tarefa 5",
    "text": "13.7 Tarefa 5\n\nVerifique que \\(G\\) pode ser gerado por 2 elementos. Dica: Pegue usando Random( G ) dois elementos aliatórios em \\(G\\) e verifique se o grupo gerado por eles coincide com \\(G\\).\nAche um subconjunto mínimo \\(S\\) do conjunto \\(\\{c,e,f,d,t,b\\}\\) de geradores tal que \\(\\left&lt;S\\right&gt;=G\\).\nConstrua a configuração da Tarefa 1 usando apenas os movimentos do conjunto \\(S\\) no ponto anterior.\nSeja \\(C\\) o conjunto de 8 peças de canto (as peças que possuem 3 cores). O grupo \\(G\\) age sobre o conjunto \\(C\\). Mostre que \\(G\\) induz \\(S_{8}\\) sobre o conjunto dessas peças. Similarmente, seja \\(L\\) o conjunto das 12 peças laterias (as peças que possuem 2 cores). Mostre que \\(G\\) induz \\(S_{12}\\) sobre \\(L\\). (Isso explica os grupos \\(A_8\\) e \\(A_{12}\\) entre os fatores de composição de \\(G\\)). Use Action( G, conj, act ).",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Grupos livres e o cubo mágico</span>"
    ]
  },
  {
    "objectID": "grafos.html",
    "href": "grafos.html",
    "title": "14  Grafos em GAP",
    "section": "",
    "text": "14.1 O grafo de Petersen\nO grafo de Petersené um grafo com muitas propriedades interessantes. O grafo de Petersen pode ser construído como o grafo com o conjunto de vértices \\[\nV=\\{\\{x,y\\}\\mid 1\\leq x&lt;y\\leq 5\\}\n\\] onde dois vértices \\(\\{x,y\\}\\) e \\(\\{u,v\\}\\) são conexos se e só se \\(\\{x,y\\}\\cap \\{u,v\\}=\\emptyset\\).\nVamos construir o grafo de Petersen em GAP. Primeiro construímos o conjunto de vértices.\nO conjunto de vértices de um grafo em GAP tem de ser uma lista [1..k]. No nosso caso, o conjunto de vértices será [1..10]. Dois vértices i e j serão conexos se Intersection( ver[i], ver[j] ) = [].\nPara construir o grafo de Petersen, nós precisamos do pacote GRAPE de GAP. O grafo vai ser construído pela função",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Grafos em GAP</span>"
    ]
  },
  {
    "objectID": "grafos.html#o-grafo-de-petersen",
    "href": "grafos.html#o-grafo-de-petersen",
    "title": "14  Grafos em GAP",
    "section": "",
    "text": "gap&gt; ver := Combinations( [1..5], 2 );\n[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 2, 3 ], [ 2, 4 ], [ 2, 5 ], \n  [ 3, 4 ], [ 3, 5 ], [ 4, 5 ] ]\n\ngap&gt; ares := [];\ngap&gt; for i in [1..10] do\n&gt; for j in [1..10] do\n&gt; if Intersection( ver[i], ver[j] ) = [] then\n&gt; Add( ares, [i,j] );\n&gt; fi;\n&gt; od;\n&gt; od;\ngap&gt; ares;\n[ [ 1, 8 ], [ 1, 9 ], [ 1, 10 ], [ 2, 6 ], [ 2, 7 ], [ 2, 10 ], [ 3, 5 ], \n  [ 3, 7 ], [ 3, 9 ], [ 4, 5 ], [ 4, 6 ], [ 4, 8 ], [ 5, 3 ], [ 5, 4 ], \n  [ 5, 10 ], [ 6, 2 ], [ 6, 4 ], [ 6, 9 ], [ 7, 2 ], [ 7, 3 ], [ 7, 8 ], \n  [ 8, 1 ], [ 8, 4 ], [ 8, 7 ], [ 9, 1 ], [ 9, 3 ], [ 9, 6 ], [ 10, 1 ], \n  [ 10, 2 ], [ 10, 5 ] ]\n\n\ngap&gt; LoadPackage( \"grape\" );\ntrue\ngap&gt; EdgeOrbitsGraph( Group(()), ares, 10 );\nrec( adjacencies := [ [ 8, 9, 10 ], [ 6, 7, 10 ], [ 5, 7, 9 ], [ 5, 6, 8 ], \n      [ 3, 4, 10 ], [ 2, 4, 9 ], [ 2, 3, 8 ], [ 1, 4, 7 ], [ 1, 3, 6 ], \n      [ 1, 2, 5 ] ], group := Group(()), isGraph := true, order := 10, \n  representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ], \n  schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10 ] )\ngap&gt; \ngap&gt; IsConnectedGraph( G );\ntrue\ngap&gt; Diameter( G );\n2\ngap&gt; Girth( G );\n5\ngap&gt; IsConnectedGraph( G );\ntrue",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Grafos em GAP</span>"
    ]
  },
  {
    "objectID": "grafos.html#tarefa",
    "href": "grafos.html#tarefa",
    "title": "14  Grafos em GAP",
    "section": "14.2 Tarefa",
    "text": "14.2 Tarefa\nSe \\(G\\) é um grupo, então definimos o grafo não comutante de \\(G\\) como sendo o grafo cujo conjunto de vértices é \\(G\\setminus Z(G)\\) e dois vertices \\(g,\\ h\\) são conexos se e só se \\(xy\\neq yx\\); ou seja, \\([x,y]=x^{-1}y^{-1}xy\\neq 1\\).\n\nEscreva uma função non_commuting_graph( G ) que devolve o grafo não comutante para um grupo finito \\(G\\).\nUse a função non_commuting_graph( G ) para investigar grafos associados a grupos finitos de ordem pequena (use a função SmallGroup). Verifique se os grafos são conexos, determine o diâmetro.\n\nAlgumas propriedades interessentas de grafos não comutantes são demonstradas neste artigo.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Grafos em GAP</span>"
    ]
  },
  {
    "objectID": "algebras.html",
    "href": "algebras.html",
    "title": "15  Anéis e álgebras",
    "section": "",
    "text": "15.1 Idempotentes e elementos nilpotentes em \\(\\mathbb Z_n\\)\nSeja \\(n\\geq 2\\) um inteiro e consideramos o anel \\(\\mathbb Z_n\\) de inteiros moduló \\(n\\) com a adição e multiplicação usuais. Em GAP esse anel pode ser construído como no seguinte exemplo.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Anéis e álgebras</span>"
    ]
  },
  {
    "objectID": "algebras.html#idempotentes-e-elementos-nilpotentes-em-mathbb-z_n",
    "href": "algebras.html#idempotentes-e-elementos-nilpotentes-em-mathbb-z_n",
    "title": "15  Anéis e álgebras",
    "section": "",
    "text": "gap&gt; R := ZmodZ(12 );\n(Integers mod 12)",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Anéis e álgebras</span>"
    ]
  },
  {
    "objectID": "algebras.html#tarefa-1",
    "href": "algebras.html#tarefa-1",
    "title": "15  Anéis e álgebras",
    "section": "15.2 Tarefa 1",
    "text": "15.2 Tarefa 1\nUm elemento \\(a\\in\\mathbb Z_n\\) chama-se nilpotente se \\(a^k=0\\) com algum \\(k\\geq 1\\) e o menor tal \\(k\\) é chamado de grau de nilpotência de \\(a\\). Um elemento \\(a\\in\\mathbb Z_n\\) chama-se idempotente se \\(a^2=a\\).\ngap&gt; a := 3*One( R );\n3\ngap&gt; IsIdempotent( a );\nfalse\n\nEscreva uma função nr_idempotents_of_zn( n ) que devolve o número de idempotentes em \\(\\mathbb Z_n\\).\nUse a função escrita no item anterior para calcular o número de idempotentes em anéis na forma \\(\\mathbb Z_{p^n}\\) onde \\(p\\) é primo. Formalize uma conjetura.\nEscreva uma função que determina se um elemento de \\(\\mathbb Z_n\\).\nEscreva uma função que devolve o número de elementos nilpotentes em \\(\\mathbb Z_n\\). Experimente a função com vários valores de \\(n\\) e tente formalizar uma conjetura.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Anéis e álgebras</span>"
    ]
  },
  {
    "objectID": "algebras.html#a-álgebra-dos-quaternions",
    "href": "algebras.html#a-álgebra-dos-quaternions",
    "title": "15  Anéis e álgebras",
    "section": "15.3 A álgebra dos quaternions",
    "text": "15.3 A álgebra dos quaternions\nSeja \\(\\mathbb F\\) um corpo e \\(\\alpha,\\ \\beta\\in\\mathbb  F\\setminus\\{0\\}\\). A álgebra generalizada dos quatérnions \\(A_{\\alpha,\\beta}\\) é um espaço vetorial de dimensão 4 sobre \\(\\mathbb F\\) gerado com a base \\(B=[1,i,j,k]\\) munido com a multiplicação dada por a tabela seguinte:\n\n\n\n\\(\\cdot\\)\n\\(1\\)\n\\(i\\)\n\\(j\\)\n\\(k\\)\n\n\n\n\n\\(1\\)\n\\(1\\)\n\\(i\\)\n\\(j\\)\n\\(k\\)\n\n\n\\(i\\)\n\\(i\\)\n\\(\\alpha\\)\n\\(k\\)\n\\(\\alpha j\\)\n\n\n\\(j\\)\n\\(j\\)\n\\(-k\\)\n\\(\\beta\\)\n\\(-\\beta i\\)\n\n\n\\(k\\)\n\\(k\\)\n\\(-\\alpha j\\)\n\\(\\beta i\\)\n\\(-\\alpha \\beta\\)\n\n\n\nA álgebra usual dos quaternions pode ser obtida como \\(A_{-1,-1}\\). Vamos construir \\(A_{1,1}\\). Em GAP tal álgebras podem ser construídas com a função AlgebraByStructureConstants. Primeiro nós inicializamos \\(T\\) como uma tabela vazia de constantes de estrutura.\ngap&gt; T := EmptySCTable( 4, 0 );\n[ [ [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ] ], \n  [ [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ] ], \n  [ [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ] ], \n  [ [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ], [ [  ], [  ] ] ], 0, 0 ]\nO primeiro argumento de EmptySCTable é a dimensão da álgebra, o segundo argumento é um zero no domínio de coeficientes.\nA multiplicação em \\(A_{1,1}\\) pode ser definida da maneira seguinte. Primeiro o produto \\(1\\cdot 1=1\\) é definido usando SetEntrySCTable.\ngap&gt; SetEntrySCTable( T, 1, 1, [1,1] );\nO primeiro argumento é o nome da tabela em que definimos o produto. O segundo e o terceiro argumentos significam que definimos o produto B[1]\\cdot B[1]. O último argumento significa que o produto é 1\\cdot B[1].\nContinuando desta maneira, definimos os produtos de \\(A_{1,1}\\).\ngap&gt; SetEntrySCTable( T, 1, 2, [1,2] );\ngap&gt; SetEntrySCTable( T, 1, 3, [1,3] );\ngap&gt; SetEntrySCTable( T, 1, 4, [1,4] );\ngap&gt; SetEntrySCTable( T, 2, 1, [1,2] );\ngap&gt; SetEntrySCTable( T, 2, 2, [1,1] );\ngap&gt; SetEntrySCTable( T, 2, 3, [1,4] );\ngap&gt; SetEntrySCTable( T, 2, 4, [1,3] );\ngap&gt; SetEntrySCTable( T, 3, 1, [1,3] );\ngap&gt; SetEntrySCTable( T, 3, 2, [-1,4] );\ngap&gt; SetEntrySCTable( T, 3, 3, [1,1] );\ngap&gt; SetEntrySCTable( T, 3, 4, [-1,2] );\ngap&gt; SetEntrySCTable( T, 4, 1, [1,4] );\ngap&gt; SetEntrySCTable( T, 4, 2, [-1,3] );\ngap&gt; SetEntrySCTable( T, 4, 3, [1,2] );\ngap&gt; SetEntrySCTable( T, 4, 4, [-1,1] );\ngap&gt; A := AlgebraByStructureConstants( F, T );",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Anéis e álgebras</span>"
    ]
  },
  {
    "objectID": "algebras.html#tarefa-2",
    "href": "algebras.html#tarefa-2",
    "title": "15  Anéis e álgebras",
    "section": "15.4 Tarefa 2",
    "text": "15.4 Tarefa 2\n\nEscreva uma função quaternion_algebra( F, a, b ) que devolve a álgebra de quatérnions \\(A_{a,b}\\) sobre \\(\\mathbb F\\).\nUse a função quaternion_algebra para construir várias álgebras sobre vários corpos. Verifique se as álgebras são simples (use IsSimpleAlgebra).",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Anéis e álgebras</span>"
    ]
  }
]